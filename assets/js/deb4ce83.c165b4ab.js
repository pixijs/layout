"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3851],{8227:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>y,frontMatter:()=>u,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"examples/layout-direction","title":"Layout Direction","description":"<ExampleEditor","source":"@site/docs/examples/layout-direction.mdx","sourceDirName":"examples","slug":"/examples/layout-direction","permalink":"/layout/docs/examples/layout-direction","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"custom_edit_url":null,"title":"Layout Direction","pagination_next":null,"pagination_prev":null},"sidebar":"examples"}');var i=n(2540),s=n(3023),a=n(6614),r=n(5430);const l="// NOTE: this should be replaced with `@pixi/layout`\nimport '/layout';\nimport Application from './boilerplate';\n\nconst defaults = {\n    backgroundColor: `#1e293b`,\n    borderWidth: 1,\n    borderColor: `#fff`,\n};\n\nexport default function App() {\n    return (\n        <Application>\n            <layoutContainer\n                layout={{\n                    ...defaults,\n                    width: 200,\n                    height: 200,\n                    padding: 10,\n                    direction: 'ltr',\n                    flexDirection: 'column',\n                    backgroundColor: `#0f172a`,\n                }}\n            >\n                <layoutContainer layout={{ ...defaults, margin: 5, height: 50, width: 50 }} />\n                <layoutContainer layout={{ ...defaults, margin: 5, height: 50, width: 50 }} />\n            </layoutContainer>\n        </Application>\n    );\n}\n",u={hide_table_of_contents:!0,hide_edit_this_page:!0,custom_edit_url:null,title:"Layout Direction",pagination_next:null,pagination_prev:null},d=void 0,c={},h=[];function p(e){return(0,i.jsx)(a.m,{files:{"/App.js":l,"/boilerplate.jsx":r.A}})}function y(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p()}},117:(e,t,n)=>{n.d(t,{K:()=>S});var o=n(3696);const i={colors:{surface1:"#242426",surface2:"#444950",surface3:"#44475a",clickable:"#fff",base:"#f8f8f2",disabled:"#6272a4",hover:"#f8f8f2",accent:"#e91e63",error:"#f8f8f2",errorSurface:"#44475a"},syntax:{plain:"#f8f8f2",comment:{color:"#6272a4",fontStyle:"italic"},keyword:"#ff79c6",tag:"#ff79c6",punctuation:"#ff79c6",definition:"#f8f8f2",property:"#50fa7b",static:"#bd93f9",string:"#f1fa8c"},font:{body:'-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',mono:'"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',size:"13px",lineHeight:"20px"}},s=e=>{const t=(0,o.useMemo)((()=>(e=>{const t=(e=>{const t=e.split(".");return t[t.length-1]})(e);return"js"===t||"jsx"===t?"javascript":"ts"===t?"typescript":"vert"===t||"frag"===t?"glsl":t})(e)),[e]);return t};const a=async e=>{const t=`pixi-definitions-${e}`,n=function(e,t){const n=localStorage.getItem(e);return JSON.parse(n)||t}(t,null);if(!n)try{const n=await fetch(`https://cdn.jsdelivr.net/npm/pixi.js@${e}/dist/pixi.js.d.ts`),o=await n.text();return o.startsWith("// Generated by dts-bundle-generator")?(localStorage.setItem(t,JSON.stringify(o)),o):null}catch(o){return console.error("Failed to fetch pixi.js types:",o),null}return n},r=function(e,t){void 0===t&&(t="latest"),(0,o.useEffect)((()=>{e&&(async e=>{const n=`declare module 'pixi.js' { ${await a(t)} }`,o="\n            declare module '*.wgsl' {\n                const shader: 'string';\n                export default shader;\n            }\n\n            declare module '*.vert' {\n                const shader: 'string';\n                export default shader;\n            }\n\n            declare module '*.frag' {\n                const shader: 'string';\n                export default shader;\n            }";e.languages.typescript.typescriptDefaults.addExtraLib(n,"file:///node_modules/pixi.js/index.d.ts"),e.languages.typescript.javascriptDefaults.addExtraLib(n,"file:///node_modules/pixi.js/index.d.ts"),e.languages.typescript.typescriptDefaults.addExtraLib(o),e.languages.typescript.javascriptDefaults.addExtraLib(o),function(e){const{languages:t}=e,n="glsl";t.register({id:n,extensions:[".frag",".vert"]}),t.setLanguageConfiguration(n,{comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]}),t.setMonarchTokensProvider(n,{tokenPostfix:".glsl",defaultToken:"invalid",directives:["#","#define","#undef","#if","#ifdef","#ifndef","#else","#elif","#endif","#error","#pragma","#extension","#version","#line"],macros:["__LINE__","__FILE__","__VERSION__"],storage:["in","out","uniform","layout","attribute","varying","precision","highp","mediump","lowp"],types:["void","bool","int","uint","float","double","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","uvec2","uvec3","uvec4","dvec2","dvec3","dvec4","mat2","mat3","mat4","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","dmat2","dmat3","dmat4","dmat2x2","dmat2x3","dmat2x4","dmat3x2","dmat3x3","dmat3x4","dmat4x2","dmat4x3","dmat4x4","sampler1D","texture1D","image1D","sampler1DShadow","sampler1DArray","texture1DArray","image1DArray","sampler1DArrayShadow","sampler2D","texture2D","image2D","sampler2DShadow","sampler2DArray","texture2DArray","image2DArray","sampler2DArrayShadow","sampler2DMS","texture2DMS","image2DMS","sampler2DMSArray","texture2DMSArray","image2DMSArray","sampler2DRect","texture2DRect","image2DRect","sampler2DRectShadow","sampler3D","texture3D","image3D","samplerCube","textureCube","imageCube","samplerCubeShadow","samplerCubeArray","textureCubeArray","imageCubeArray","samplerCubeArrayShadow","samplerBuffer","textureBuffer","imageBuffer","subpassInput","subpassInputMS","isampler1D","itexture1D","iimage1D","isampler1DArray","itexture1DArray","iimage1DArray","isampler2D","itexture2D","iimage2D","isampler2DArray","itexture2DArray","iimage2DArray","isampler2DMS","itexture2DMS","iimage2DMS","isampler2DMSArray","itexture2DMSArray","iimage2DMSArray","isampler2DRect","itexture2DRect","iimage2DRect","isampler3D","itexture3D","iimage3D","isamplerCube","itextureCube","iimageCube","isamplerCubeArray","itextureCubeArray","iimageCubeArray","isamplerBuffer","itextureBuffer","iimageBuffer","isubpassInput","isubpassInputMS","usampler1D","utexture1D","uimage1D","usampler1DArray","utexture1DArray","uimage1DArray","usampler2D","utexture2D","uimage2D","usampler2DArray","utexture2DArray","uimage2DArray","usampler2DMS","utexture2DMS","uimage2DMS","usampler2DMSArray","utexture2DMSArray","uimage2DMSArray","usampler2DRect","utexture2DRect","uimage2DRect","usampler3D","utexture3D","uimage3D","usamplerCube","utextureCube","uimageCube","usamplerCubeArray","utextureCubeArray","uimageCubeArray","usamplerBuffer","utextureBuffer","uimageBuffer","atomic_uint","usubpassInput","usubpassInputMS","sampler","samplerShadow"],operators:["*","+","-","/","~","!","%","<<",">>","<",">","<=",">=","==","!=","&","^","|","&&","^^","||","=","+=","-=","*=","/=","%=","<<=",">>=","&=","^=","|="],builtin_vars:["gl_VertexID","gl_InstanceID","gl_VertexIndex","gl_InstanceIndex","gl_DrawID","gl_BaseVertex","gl_BaseInstance","gl_Position","gl_PointSize","gl_ClipDistance","gl_CullDistance","gl_Color","gl_SecondaryColor","gl_Normal","gl_Vertex","gl_MultiTexCoord0","gl_MultiTexCoord1","gl_MultiTexCoord2","gl_MultiTexCoord3","gl_MultiTexCoord4","gl_MultiTexCoord5","gl_MultiTexCoord6","gl_MultiTexCoord7","gl_FogCoord"],constants:["gl_MaxVertexAttribs","gl_MaxVertexUniformVectors","gl_MaxVertexUniformComponents","gl_MaxVertexOutputComponents"],intsuffix:"[uU]?",floatsuffix:"([fF]|(fl|FL))?",tokenizer:{root:[[/\/\/.*$/,"comment.line"],[/\/\*/,"comment.block","@comment"],[/#[a-z]*/,{cases:{"@directives":"keyword.control.preprocessor","@default":"invalid"}}],["GL_ES","meta.preprocessor"],[/__[A-Z_]+__/,{cases:{"@macros":"meta.preprocessor","@default":"invalid"}}],[/[{}()\[\]]/,"@brackets"],[/(true|false)/,"constant"],[/[\=\+\-\*\/\>\<\&\|\%\!\^]+/,{cases:{"@operators":"operator","@default":"invalid"}}],[/[a-zA-Z][a-zA-Z0-9_]*(?=\()/,"entity.name.function"],[/[a-zA-Z][a-zA-Z0-9_]*/,{cases:{"@storage":"storage.type","@types":"entity.name.type","@builtin_vars":"keyword","@default":"variable.name"}}],[/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/,"number.float"],[/0[xX][0-9a-fA-F](@intsuffix)/,"number.hex"],[/0[0-7](@intsuffix)/,"number.octal"],[/\d+(@intsuffix)/,"number"],[/[;,.]/,"delimiter"]],comment:[["\\*/","comment.block","@pop"],[".*","comment.block"]]}})}(e)})(e)}),[e,t])};var l=n(4691),u=n(4996),d=n(9511),c=n(2540);function h(e){let{fontSize:t=12,style:n,pixiVersion:o,handleEditorCodeChanged:i}=e;const{code:a,updateCode:h}=(0,l.Pe)(),{sandpack:p}=(0,l.ny)(),y=(0,d.dJ)(),g=s(p.activeFile),{colorMode:f}=(0,u.G)();return r(y,o),(0,c.jsxs)(l.aN,{style:{height:"100%",margin:0,...n},children:[(0,c.jsx)(l.fQ,{}),(0,c.jsx)("div",{style:{flex:1,paddingTop:8,background:"dark"===f?"#1e1e1e":"#FFFFFE"},children:(0,c.jsx)(d.KE,{width:"100%",height:"100%",language:g,theme:"dark"===f?"vs-dark":"light",defaultValue:a,onChange:e=>{h(e||""),i?.(e)},options:{minimap:{enabled:!1},scrollBeyondLastLine:!1,wordWrap:"on",automaticLayout:!0,fontSize:t}},p.activeFile)})]})}const p=e=>{let{onClick:t}=e;return(0,c.jsx)(l.Gb,{style:{position:"relative"},onClick:t,children:(0,c.jsx)(l.D0,{})})},y=e=>{let{onSelectionChange:t,defaultSelection:n="both"}=e;const[i,s]=(0,o.useState)(n),{colorMode:a}=(0,u.G)(),r=e=>{s(e),t(e)},l={height:"100%",width:"max-content",padding:"0 16px",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",color:"dark"===a?"#F6F8FA":"#2E3138",border:"none"},d="dark"===a?"#22232A":"#e2e2e2";return(0,c.jsxs)("div",{style:{height:32,width:"100%",overflow:"hidden",backgroundColor:"dark"===a?"#2E3138":"#F6F8FA",display:"flex",justifyContent:"right",borderBottomLeftRadius:4,borderBottomRightRadius:4},children:[(0,c.jsx)("button",{onClick:()=>r("editor"),style:{backgroundColor:"editor"===i?d:"transparent",...l},children:"Editor"}),(0,c.jsx)("button",{onClick:()=>r("preview"),style:{backgroundColor:"preview"===i?d:"transparent",...l},children:"Preview"}),(0,c.jsx)("button",{onClick:()=>r("both"),style:{backgroundColor:"both"===i?d:"transparent",...l},children:"Both"})]})};function g(e){const{viewType:t,showConsole:n,fontSize:i,pixiVersion:s}=e,[a,r]=(0,o.useState)(n),[u,d]=(0,o.useState)(t),g=(0,c.jsx)(c.Fragment,{children:(0,c.jsx)(p,{onClick:()=>r((e=>!e))})});return(0,c.jsxs)("div",{style:{height:"100%",width:"100%",display:"flex",flexDirection:"column"},children:[(0,c.jsxs)(l.am,{style:{height:"100%",overflow:"hidden",borderBottomLeftRadius:0,borderBottomRightRadius:0,flexWrap:"nowrap"},children:[(0,c.jsx)(h,{fontSize:i,style:{flexGrow:"preview"!==u?1:0,flexShrink:"preview"!==u?1:0,flexBasis:"editor"===u?"100%":0,width:"100%",overflow:"hidden"},pixiVersion:s,handleEditorCodeChanged:e.handleEditorCodeChanged}),(0,c.jsxs)(l.aN,{style:{height:"100%",width:"100%"},children:[(0,c.jsx)(l.G5,{style:{flexGrow:"editor"!==u?100:0,flexShrink:"editor"!==u?100:0,flexBasis:"editor"!==u?"100%":0,overflow:"hidden"},showOpenInCodeSandbox:!1,actionsChildren:g}),a&&(0,c.jsx)("div",{style:{flexGrow:a?35:0,flexShrink:a?35:0,flexBasis:a?"35%":0,width:"100%",overflow:"hidden"},children:(0,c.jsx)(l.X2,{showHeader:!1})})]})]}),(0,c.jsx)(y,{onSelectionChange:e=>{d(e)},defaultSelection:u})]})}const f='var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);\nimport { Bounds, ExtensionType, ViewContainer, TilingSprite as TilingSprite$1, NineSliceSprite as NineSliceSprite$1, Container, extensions, Point, AbstractText, Rectangle, Graphics as Graphics$1, BigPool } from "pixi.js";\nimport { loadYoga, Direction, Align, BoxSizing, Display, FlexDirection, Wrap, Justify, Overflow, PositionType, Edge, Gutter } from "yoga-layout/load";\nlet yoga;\nfunction getYoga() {\n  return yoga;\n}\nfunction setYoga(newYoga) {\n  yoga = newYoga;\n}\nfunction getNumberFromStyle(value, size) {\n  if (!value) return 0;\n  if (typeof value === "number") {\n    return value;\n  } else if (typeof value === "string" && value.endsWith("%")) {\n    size ?? (size = 1);\n    return size * (parseFloat(value) / 100);\n  } else if (!Number.isNaN(parseFloat(value))) {\n    return parseFloat(value);\n  }\n  return 0;\n}\nfunction getTypeFromStyle(value) {\n  if (typeof value === "number") return "number";\n  if (value.endsWith("%")) return "percentage";\n  if (Number.isNaN(parseInt(value, 10))) return "keyword";\n  return "number";\n}\nfunction calculateCenterPosition(dimension, computedLayout, visualBounds) {\n  return (computedLayout[dimension] - visualBounds[dimension]) / 2;\n}\nfunction calculateNonKeywordPosition(value, valueType, dimension, computedLayout, visualBounds) {\n  const multiple = valueType === "percentage" ? computedLayout[dimension] - visualBounds[dimension] : 1;\n  return getNumberFromStyle(value) * multiple;\n}\nfunction calculateWithDoubleValue(tokens, computedLayout, visualBounds) {\n  const [first, second] = tokens;\n  const firstType = getTypeFromStyle(first);\n  const secondType = getTypeFromStyle(second);\n  const result = { x: void 0, y: void 0 };\n  switch (first) {\n    case "top":\n      result.y = 0;\n      break;\n    case "bottom":\n      result.y = computedLayout.height - visualBounds.height;\n      break;\n    case "center":\n      if (second === "left" || second === "right") {\n        result.y = calculateCenterPosition("height", computedLayout, visualBounds);\n      } else {\n        result.x = calculateCenterPosition("width", computedLayout, visualBounds);\n      }\n      break;\n    case "left":\n      result.x = 0;\n      break;\n    case "right":\n      result.x = computedLayout.width - visualBounds.width;\n      break;\n    default: {\n      const dimension = second === "top" || second === "bottom" || secondType !== "keyword" ? "width" : "height";\n      const target = dimension === "width" ? "x" : "y";\n      result[target] = calculateNonKeywordPosition(first, firstType, dimension, computedLayout, visualBounds);\n    }\n  }\n  switch (second) {\n    case "top":\n      result.y = 0;\n      break;\n    case "bottom":\n      result.y = computedLayout.height - visualBounds.height;\n      break;\n    case "center":\n      if (result.y === void 0) {\n        result.y = calculateCenterPosition("height", computedLayout, visualBounds);\n      } else {\n        result.x = calculateCenterPosition("width", computedLayout, visualBounds);\n      }\n      break;\n    case "left":\n      result.x = 0;\n      break;\n    case "right":\n      result.x = computedLayout.width - visualBounds.width;\n      break;\n    default: {\n      const target = result.y === void 0 ? "y" : "x";\n      const dimension = target === "y" ? "height" : "width";\n      result[target] = calculateNonKeywordPosition(second, secondType, dimension, computedLayout, visualBounds);\n    }\n  }\n  return result;\n}\nfunction calculateAxisOffset(keyword, value, type, bounds) {\n  const isNegativeOffset = keyword === "right" || keyword === "bottom";\n  const offset = type === "percentage" ? value * bounds : value;\n  return isNegativeOffset ? -offset : offset;\n}\nfunction calculateWithQuadValue(tokens, computedLayout, visualBounds) {\n  const [first, second, third, fourth] = tokens;\n  const firstType = getTypeFromStyle(first);\n  const secondType = getTypeFromStyle(second);\n  const thirdType = getTypeFromStyle(third);\n  const fourthType = getTypeFromStyle(fourth);\n  if (secondType === "keyword" || fourthType === "keyword") {\n    throw new Error("Invalid objectPosition value: second and fourth values must be numbers or percentages");\n  }\n  if (firstType !== "keyword" || thirdType !== "keyword") {\n    throw new Error("Invalid objectPosition value: first and third values must be keywords");\n  }\n  const basePosition = calculateWithDoubleValue([first, third], computedLayout, visualBounds);\n  const result = { ...basePosition };\n  const secondValue = getNumberFromStyle(second);\n  const fourthValue = getNumberFromStyle(fourth);\n  if (first === "left" || first === "right") {\n    result.x = basePosition.x + calculateAxisOffset(first, secondValue, secondType, visualBounds.width);\n  } else if (first === "top" || first === "bottom") {\n    result.y = basePosition.y + calculateAxisOffset(first, secondValue, secondType, visualBounds.height);\n  }\n  if (third === "left" || third === "right") {\n    result.x = basePosition.x + calculateAxisOffset(third, fourthValue, fourthType, visualBounds.width);\n  } else if (third === "top" || third === "bottom") {\n    result.y = basePosition.y + calculateAxisOffset(third, fourthValue, fourthType, visualBounds.height);\n  }\n  return result;\n}\nfunction calculateWithSingleValue(tokens, computedLayout, visualBounds) {\n  const keyword = tokens[0];\n  const result = { x: void 0, y: void 0 };\n  switch (keyword) {\n    case "top":\n      result.y = 0;\n      result.x = (computedLayout.width - visualBounds.width) / 2;\n      break;\n    case "bottom":\n      result.y = computedLayout.height - visualBounds.height;\n      result.x = (computedLayout.width - visualBounds.width) / 2;\n      break;\n    case "left":\n      result.x = 0;\n      result.y = (computedLayout.height - visualBounds.height) / 2;\n      break;\n    case "right":\n      result.x = computedLayout.width - visualBounds.width;\n      result.y = (computedLayout.height - visualBounds.height) / 2;\n      break;\n    case "center":\n      result.x = (computedLayout.width - visualBounds.width) / 2;\n      result.y = (computedLayout.height - visualBounds.height) / 2;\n      break;\n    default: {\n      const isPercentage = getTypeFromStyle(keyword) === "percentage";\n      const multiple = isPercentage ? computedLayout.width - visualBounds.width : 1;\n      result.x = getNumberFromStyle(keyword) * multiple;\n      result.y = (computedLayout.height - visualBounds.height) / 2;\n    }\n  }\n  return result;\n}\nfunction calculatePositionSpecifier(value, computedLayout, visualBounds) {\n  if (!value) return { x: 0, y: 0 };\n  const tokens = typeof value === "string" ? value.split(" ") : [value];\n  switch (tokens.length) {\n    case 1:\n      return calculateWithSingleValue(tokens, computedLayout, visualBounds);\n    case 2:\n      return calculateWithDoubleValue(tokens, computedLayout, visualBounds);\n    case 4:\n      return calculateWithQuadValue(tokens, computedLayout, visualBounds);\n    default:\n      throw new Error("Invalid objectPosition value: must have 1, 2, or 4 values");\n  }\n}\nconst tempBounds = new Bounds();\nconst temp = { width: 0, height: 0 };\nfunction getPixiSize(layout) {\n  const bounds = layout.target.getLocalBounds(tempBounds);\n  const scale = layout.target.scale;\n  temp.width = Math.abs(bounds.width * scale.x);\n  temp.height = Math.abs(bounds.height * scale.y);\n  return temp;\n}\nfunction nearlyEqual(a, b, EPSILON = 0.49) {\n  return Math.abs(a - b) < EPSILON;\n}\nconst throttleMap = /* @__PURE__ */ new Map();\nfunction throttle(fun, delay = 100, scope) {\n  if (!throttleMap.has(fun)) {\n    let timerId = null;\n    const throttledFunction = (...args) => {\n      throttleMap.get(fun).args = args;\n      if (timerId) return;\n      const callFun = () => {\n        timerId = null;\n        const latestArgs = throttleMap.get(fun).args;\n        {\n          fun(...latestArgs);\n        }\n      };\n      if (delay === 0) {\n        callFun();\n      } else {\n        timerId = setTimeout(callFun, delay);\n      }\n    };\n    throttleMap.set(fun, { throttledFunction, args: null });\n  }\n  return throttleMap.get(fun).throttledFunction;\n}\nclass LayoutSystem {\n  constructor() {\n    /**\n     * Whether the layout system should automatically update the layout when it detects changes\n     * @default true\n     */\n    __publicField(this, "autoUpdate", true);\n    __publicField(this, "_debugEnabled", false);\n    __publicField(this, "_debugRenderer", null);\n    __publicField(this, "_throttledUpdateSize");\n    __publicField(this, "_throttle", 100);\n    __publicField(this, "_modificationCount", 50);\n  }\n  /**\n   * Initializes the layout system by loading the Yoga library asynchronously\n   * @returns A promise that resolves when the system is ready\n   */\n  async init(options) {\n    setYoga(await loadYoga());\n    const { layout } = options ?? {};\n    const { autoUpdate, enableDebug, throttle: throttle$1, debugModificationCount } = layout ?? {};\n    if (enableDebug) {\n      void this.enableDebug(true);\n    }\n    if (autoUpdate !== void 0) {\n      this.autoUpdate = autoUpdate;\n    }\n    this._throttle = throttle$1 ?? this._throttle;\n    this._throttledUpdateSize = throttle((container) => this._updateSize(container), this._throttle);\n    this._modificationCount = debugModificationCount ?? this._modificationCount;\n  }\n  /**\n   * Toggles the debug mode for the layout system\n   * @param value - Whether to enable or disable debug mode\n   */\n  async enableDebug(value = !this._debugEnabled) {\n    this._debugEnabled = value;\n    if (!this._debugRenderer) {\n      const res = await Promise.resolve().then(() => DebugRenderer$1);\n      this._debugRenderer = new res.DebugRenderer();\n    }\n    if (!this._debugEnabled) {\n      this._debugRenderer.reset();\n    }\n  }\n  /**\n   * Updates the layout of the container and its children\n   * @param container - The container to update the layout for\n   */\n  update(container) {\n    if (this._debugEnabled && this._debugRenderer) {\n      this._debugRenderer.reset();\n      container.addChild(this._debugRenderer.holder);\n    }\n    this._throttledUpdateSize(container);\n    this.updateLayout(container);\n  }\n  prerender({ container }) {\n    if (this.autoUpdate) {\n      this.update(container);\n    }\n  }\n  /**\n   * Updates the size of the yoga nodes for the containers that use pixi size\n   * @param container - The container to update the size for\n   */\n  _updateSize(container) {\n    const layout = container._layout;\n    if (layout) {\n      const layoutStyles = layout.style;\n      if (layoutStyles.width === "intrinsic" || layoutStyles.height === "intrinsic") {\n        const size = getPixiSize(layout);\n        if (layoutStyles.width === "intrinsic") {\n          const currentWidth = layout.yoga.getWidth().value;\n          if (!nearlyEqual(currentWidth, size.width)) {\n            layout.yoga.setWidth(size.width);\n            layout.invalidateRoot();\n          }\n        }\n        if (layoutStyles.height === "intrinsic") {\n          const currentHeight = layout.yoga.getHeight().value;\n          if (!nearlyEqual(currentHeight, size.height)) {\n            layout.yoga.setHeight(size.height);\n            layout.invalidateRoot();\n          }\n        }\n      }\n      if (!container.visible) {\n        layout._onChildRemoved();\n        return;\n      }\n    }\n    for (let i = 0; i < container.children.length; i++) {\n      this._updateSize(container.children[i]);\n    }\n  }\n  /**\n   * Updates the layout of the container and its children\n   * @param container - The container to update the layout for\n   */\n  updateLayout(container) {\n    var _a, _b, _c, _d;\n    const layout = container._layout;\n    if (!container.visible) {\n      return;\n    }\n    if (layout) {\n      const yogaNode = layout.yoga;\n      const layoutStyles = layout.style;\n      const isOverflowContainer = (_a = container.parent) == null ? void 0 : _a.isOverflowContainer;\n      const hasParentLayout = (_b = container.parent) == null ? void 0 : _b._layout;\n      if (!hasParentLayout && !isOverflowContainer) {\n        if (layout._isDirty) {\n          layout._isDirty = false;\n          yogaNode.calculateLayout(\n            layoutStyles.width,\n            // TODO: if this is not a number, it will not work\n            layoutStyles.height,\n            yogaNode.getDirection() ?? Direction.LTR\n          );\n        }\n      }\n      if (yogaNode.hasNewLayout() || layout._forceUpdate) {\n        yogaNode.markLayoutSeen();\n        layout._forceUpdate = false;\n        layout._computedLayout = yogaNode.getComputedLayout();\n        const res = calculatePositionSpecifier(layoutStyles.transformOrigin, layout._computedLayout, {\n          width: 0,\n          height: 0\n        });\n        layout._computedPixiLayout = {\n          ...container.computeLayoutData(layout._computedLayout),\n          originX: res.x,\n          originY: res.y\n        };\n        container.emit("layout", layout);\n        (_c = container.onLayout) == null ? void 0 : _c.call(container, layout);\n        container._onUpdate();\n      }\n      if (this._debugEnabled) {\n        if (layout._styles.custom.debug || layout._modificationCount > this._modificationCount && layout._styles.custom.debugHeat !== false) {\n          (_d = this._debugRenderer) == null ? void 0 : _d.render(layout);\n        }\n      }\n    }\n    for (let i = 0; i < container.children.length; i++) {\n      this.updateLayout(container.children[i]);\n    }\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    if (!this._debugEnabled && this._debugRenderer) {\n      this._debugRenderer.destroy();\n    }\n  }\n}\n/** @ignore */\n__publicField(LayoutSystem, "extension", {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n  name: "layout"\n});\nconst ALIGN_CONTENT_MAP = {\n  "flex-start": Align.FlexStart,\n  "flex-end": Align.FlexEnd,\n  center: Align.Center,\n  stretch: Align.Stretch,\n  "space-between": Align.SpaceBetween,\n  "space-around": Align.SpaceAround,\n  "space-evenly": Align.SpaceEvenly\n};\nconst ALIGN_ITEMS_MAP = {\n  "flex-start": Align.FlexStart,\n  "flex-end": Align.FlexEnd,\n  center: Align.Center,\n  stretch: Align.Stretch,\n  baseline: Align.Baseline\n};\nconst BOX_SIZING_MAP = {\n  "border-box": BoxSizing.BorderBox,\n  "content-box": BoxSizing.ContentBox\n};\nconst DIRECTION_MAP = {\n  ltr: Direction.LTR,\n  rtl: Direction.RTL\n};\nconst DISPLAY_MAP = {\n  none: Display.None,\n  flex: Display.Flex,\n  contents: Display.Contents\n};\nconst FLEX_DIRECTION_MAP = {\n  row: FlexDirection.Row,\n  column: FlexDirection.Column,\n  "row-reverse": FlexDirection.RowReverse,\n  "column-reverse": FlexDirection.ColumnReverse\n};\nconst FLEX_WRAP_MAP = {\n  wrap: Wrap.Wrap,\n  nowrap: Wrap.NoWrap,\n  "wrap-reverse": Wrap.WrapReverse\n};\nconst JUSTIFY_CONTENT_MAP = {\n  "flex-start": Justify.FlexStart,\n  "flex-end": Justify.FlexEnd,\n  center: Justify.Center,\n  "space-between": Justify.SpaceBetween,\n  "space-around": Justify.SpaceAround,\n  "space-evenly": Justify.SpaceEvenly\n};\nconst OVERFLOW_MAP = {\n  visible: Overflow.Visible,\n  hidden: Overflow.Hidden,\n  scroll: Overflow.Scroll\n};\nconst POSITION_MAP = {\n  absolute: PositionType.Absolute,\n  relative: PositionType.Relative,\n  static: PositionType.Static\n};\nconst styleSetters = {\n  alignContent: (node, value) => node.setAlignContent(alignContent(value)),\n  alignItems: (node, value) => node.setAlignItems(alignItems(value)),\n  alignSelf: (node, value) => node.setAlignSelf(alignItems(value)),\n  aspectRatio: (node, value) => node.setAspectRatio(value),\n  borderBottomWidth: (node, value) => node.setBorder(Edge.Bottom, value),\n  borderEndWidth: (node, value) => node.setBorder(Edge.End, value),\n  borderLeftWidth: (node, value) => node.setBorder(Edge.Left, value),\n  borderRightWidth: (node, value) => node.setBorder(Edge.Right, value),\n  borderStartWidth: (node, value) => node.setBorder(Edge.Start, value),\n  borderTopWidth: (node, value) => node.setBorder(Edge.Top, value),\n  borderWidth: (node, value) => node.setBorder(Edge.All, value),\n  borderInlineWidth: (node, value) => node.setBorder(Edge.Horizontal, value),\n  borderBlockWidth: (node, value) => node.setBorder(Edge.Vertical, value),\n  bottom: (node, value) => node.setPosition(Edge.Bottom, value),\n  boxSizing: (node, value) => node.setBoxSizing(boxSizing(value)),\n  direction: (node, value) => node.setDirection(direction(value)),\n  display: (node, value) => node.setDisplay(display(value)),\n  end: (node, value) => node.setPosition(Edge.End, value),\n  flex: (node, value) => node.setFlex(value),\n  flexBasis: (node, value) => node.setFlexBasis(value),\n  flexDirection: (node, value) => node.setFlexDirection(flexDirection(value)),\n  rowGap: (node, value) => node.setGap(Gutter.Row, value),\n  gap: (node, value) => node.setGap(Gutter.All, value),\n  columnGap: (node, value) => node.setGap(Gutter.Column, value),\n  flexGrow: (node, value) => node.setFlexGrow(value),\n  flexShrink: (node, value) => node.setFlexShrink(value),\n  flexWrap: (node, value) => node.setFlexWrap(flexWrap(value)),\n  height: (node, value) => node.setHeight(value),\n  justifyContent: (node, value) => node.setJustifyContent(justifyContent(value)),\n  left: (node, value) => node.setPosition(Edge.Left, value),\n  margin: (node, value) => node.setMargin(Edge.All, value),\n  marginBottom: (node, value) => node.setMargin(Edge.Bottom, value),\n  marginEnd: (node, value) => node.setMargin(Edge.End, value),\n  marginLeft: (node, value) => node.setMargin(Edge.Left, value),\n  marginRight: (node, value) => node.setMargin(Edge.Right, value),\n  marginStart: (node, value) => node.setMargin(Edge.Start, value),\n  marginTop: (node, value) => node.setMargin(Edge.Top, value),\n  marginInline: (node, value) => node.setMargin(Edge.Horizontal, value),\n  marginBlock: (node, value) => node.setMargin(Edge.Vertical, value),\n  maxHeight: (node, value) => node.setMaxHeight(value),\n  maxWidth: (node, value) => node.setMaxWidth(value),\n  minHeight: (node, value) => node.setMinHeight(value),\n  minWidth: (node, value) => node.setMinWidth(value),\n  overflow: (node, value) => node.setOverflow(overflow(value)),\n  padding: (node, value) => node.setPadding(Edge.All, value),\n  paddingBottom: (node, value) => node.setPadding(Edge.Bottom, value),\n  paddingEnd: (node, value) => node.setPadding(Edge.End, value),\n  paddingLeft: (node, value) => node.setPadding(Edge.Left, value),\n  paddingRight: (node, value) => node.setPadding(Edge.Right, value),\n  paddingStart: (node, value) => node.setPadding(Edge.Start, value),\n  paddingTop: (node, value) => node.setPadding(Edge.Top, value),\n  paddingInline: (node, value) => node.setPadding(Edge.Horizontal, value),\n  paddingBlock: (node, value) => node.setPadding(Edge.Vertical, value),\n  position: (node, value) => node.setPositionType(position(value)),\n  right: (node, value) => node.setPosition(Edge.Right, value),\n  start: (node, value) => node.setPosition(Edge.Start, value),\n  top: (node, value) => node.setPosition(Edge.Top, value),\n  insetInline: (node, value) => node.setPosition(Edge.Horizontal, value),\n  insetBlock: (node, value) => node.setPosition(Edge.Vertical, value),\n  inset: (node, value) => node.setPosition(Edge.All, value),\n  width: (node, value) => node.setWidth(value)\n};\nfunction alignContent(str) {\n  if (str in ALIGN_CONTENT_MAP) return ALIGN_CONTENT_MAP[str];\n  throw new Error(`"${str}" is not a valid value for alignContent`);\n}\nfunction alignItems(str) {\n  if (str in ALIGN_ITEMS_MAP) return ALIGN_ITEMS_MAP[str];\n  throw new Error(`"${str}" is not a valid value for alignItems`);\n}\nfunction boxSizing(str) {\n  if (str in BOX_SIZING_MAP) return BOX_SIZING_MAP[str];\n  throw new Error(`"${str}" is not a valid value for boxSizing`);\n}\nfunction direction(str) {\n  if (str in DIRECTION_MAP) return DIRECTION_MAP[str];\n  throw new Error(`"${str}" is not a valid value for direction`);\n}\nfunction display(str) {\n  if (str in DISPLAY_MAP) return DISPLAY_MAP[str];\n  throw new Error(`"${str}" is not a valid value for display`);\n}\nfunction flexDirection(str) {\n  if (str in FLEX_DIRECTION_MAP) return FLEX_DIRECTION_MAP[str];\n  throw new Error(`"${str}" is not a valid value for flexDirection`);\n}\nfunction flexWrap(str) {\n  if (str in FLEX_WRAP_MAP) return FLEX_WRAP_MAP[str];\n  throw new Error(`"${str}" is not a valid value for flexWrap`);\n}\nfunction justifyContent(str) {\n  if (str in JUSTIFY_CONTENT_MAP) return JUSTIFY_CONTENT_MAP[str];\n  throw new Error(`"${str}" is not a valid value for justifyContent`);\n}\nfunction overflow(str) {\n  if (str in OVERFLOW_MAP) return OVERFLOW_MAP[str];\n  throw new Error(`"${str}" is not a valid value for overflow`);\n}\nfunction position(str) {\n  if (str in POSITION_MAP) return POSITION_MAP[str];\n  throw new Error(`"${str}" is not a valid value for position`);\n}\nfunction applyStyle(node, style = {}) {\n  for (const [key, value] of Object.entries(style)) {\n    try {\n      const setter = styleSetters[key];\n      if (setter) {\n        setter(node, value);\n      }\n    } catch (_e) {\n    }\n  }\n  if (style.width !== void 0) {\n    const widthValue = style.left !== void 0 && style.right !== void 0 ? "auto" : style.width;\n    node.setWidth(widthValue);\n  }\n  if (style.height !== void 0) {\n    const heightValue = style.top !== void 0 && style.bottom !== void 0 ? "auto" : style.height;\n    node.setHeight(heightValue);\n  }\n}\nfunction formatStyles(layout, style) {\n  const currentStyles = layout._styles;\n  let customStyles = { ...currentStyles.custom, ...style };\n  const defaultStyle = {\n    ...Layout.defaultStyle.shared,\n    ...layout.target instanceof ViewContainer || customStyles.isLeaf || Layout.defaultStyle.shared.isLeaf ? Layout.defaultStyle.leaf : Layout.defaultStyle.container\n  };\n  customStyles = { ...defaultStyle, ...customStyles };\n  const yogaStyles = { ...customStyles };\n  const widthIntrinsic = customStyles.width === "intrinsic";\n  const heightIntrinsic = customStyles.height === "intrinsic";\n  if (widthIntrinsic || heightIntrinsic) {\n    const { width, height } = getPixiSize(layout);\n    if (widthIntrinsic) {\n      yogaStyles.width = width;\n    }\n    if (heightIntrinsic) {\n      yogaStyles.height = height;\n    }\n  }\n  return { custom: customStyles, yoga: yogaStyles };\n}\nfunction onChildAdded(layout, pixiParent) {\n  var _a;\n  let parentLayout = pixiParent.layout;\n  let yogaIndex = -1;\n  if (!parentLayout && pixiParent.isOverflowContainer) {\n    parentLayout = (_a = pixiParent.parent) == null ? void 0 : _a.layout;\n    yogaIndex = pixiParent.children.indexOf(layout.target);\n    pixiParent = pixiParent.parent;\n  }\n  if (parentLayout) {\n    const yogaParent = layout.yoga.getParent();\n    if (yogaParent) {\n      yogaParent.removeChild(layout.yoga);\n    }\n    if (pixiParent.children.indexOf(layout.target) === pixiParent.children.length - 1 && yogaIndex === -1) {\n      parentLayout.yoga.insertChild(layout.yoga, parentLayout.yoga.getChildCount());\n      return;\n    }\n    for (let i = 0; i < pixiParent.children.length; i++) {\n      const child = pixiParent.children[i];\n      if (child.layout && child.visible) {\n        yogaIndex++;\n      }\n      if (child === layout.target) {\n        break;\n      }\n    }\n    parentLayout.yoga.insertChild(layout.yoga, yogaIndex);\n  }\n}\nfunction onChildRemoved(layout) {\n  const yogaParent = layout.yoga.getParent();\n  yogaParent && yogaParent.removeChild(layout.yoga);\n}\nclass Layout {\n  constructor({ target }) {\n    /** The Yoga node instance for this layout */\n    __publicField(this, "yoga");\n    /** The target PixiJS container */\n    __publicField(this, "target");\n    /**\n     * Flag indicating if layout needs recalculation\n     * @ignore\n     */\n    __publicField(this, "_isDirty", false);\n    /**\n     * The computed pixi layout that is applied to the target container in the updateLocalTransform step\n     * @ignore\n     */\n    __publicField(this, "_computedPixiLayout", {\n      /** The left value of the view */\n      x: 0,\n      /** The top value of the view */\n      y: 0,\n      /** The offset x value of the view within its box */\n      offsetX: 0,\n      /** The offset y value of the view within its box */\n      offsetY: 0,\n      /** The scale x value of the view within its box */\n      scaleX: 1,\n      /** The scale y value of the view within its box */\n      scaleY: 1,\n      /** The x origin of the view */\n      originX: 0,\n      /** The y origin of the view */\n      originY: 0\n    });\n    /**\n     * The computed bounds of the yoga node\n     * @ignore\n     */\n    __publicField(this, "_computedLayout", {\n      /** The left value of the view */\n      left: 0,\n      /** The right value of the view */\n      right: 0,\n      /** The top value of the view */\n      top: 0,\n      /** The bottom value of the view */\n      bottom: 0,\n      /** The width of the view */\n      width: 0,\n      /** The height of the view */\n      height: 0\n    });\n    /**\n     * The styles used for layout calculation\n     * @ignore\n     */\n    __publicField(this, "_styles", {\n      custom: {},\n      yoga: {}\n    });\n    /**\n     * The number of times the layout has been modified\n     * @ignore\n     */\n    __publicField(this, "_modificationCount", 0);\n    /**\n     * Flag indicating if the layout should be recalculated even if it hasn\'t changed the yoga node.\n     * This is used to force an update when certain style properties change such as `objectFit`.\n     * @ignore\n     */\n    __publicField(this, "_forceUpdate", false);\n    /**\n     * Flag indicating if the layout has a parent node\n     */\n    __publicField(this, "hasParent", false);\n    /**\n     * The keys to track for changes to force an update\n     * @ignore\n     */\n    __publicField(this, "_trackedStyleKeys", [\n      "borderRadius",\n      "borderColor",\n      "backgroundColor",\n      "objectFit",\n      "objectPosition",\n      "transformOrigin",\n      "isLeaf"\n    ]);\n    this.target = target;\n    this.yoga = getYoga().Node.create();\n    target.on("added", this._onChildAdded, this);\n    target.on("removed", this._onChildRemoved, this);\n    target.on("destroyed", this.destroy, this);\n  }\n  /** Returns the layout style */\n  get style() {\n    return this._styles.custom;\n  }\n  /** Returns the computed layout of the yoga node */\n  get computedLayout() {\n    return this._computedLayout;\n  }\n  /** Returns the computed layout of the pixi node */\n  get computedPixiLayout() {\n    return this._computedPixiLayout;\n  }\n  /**\n   * Returns the true x position of the target.\n   *\n   * When an element is in layout, the x/y position is an offset from where it is laid out.\n   * This is the true x position of the element in the parent container.\n   */\n  get realX() {\n    return this.target.localTransform.tx;\n  }\n  /**\n   * Returns the true y position of the target.\n   *\n   * When an element is in layout, the x/y position is an offset from where it is laid out.\n   * This is the true y position of the element in the parent container.\n   */\n  get realY() {\n    return this.target.localTransform.ty;\n  }\n  /**\n   * Returns the true x scale of the target.\n   *\n   * When an element is in layout, the scale is an offset from 1.\n   * This is the true x scale of the element.\n   */\n  get realScaleX() {\n    return this.target.localTransform.a;\n  }\n  /**\n   * Returns the true y scale of the target.\n   *\n   * When an element is in layout, the scale is an offset from 1.\n   * This is the true y scale of the element.\n   */\n  get realScaleY() {\n    return this.target.localTransform.d;\n  }\n  /**\n   * Updates the layout style and triggers recalculation\n   * @param style - New layout style to apply\n   */\n  setStyle(style) {\n    const styles = formatStyles(this, style);\n    const differentCustom = JSON.stringify(this._styles.custom) !== JSON.stringify(styles.custom);\n    const differentYoga = JSON.stringify(this._styles.yoga) !== JSON.stringify(styles.yoga);\n    const different = differentCustom || differentYoga;\n    const hasTrackedChanges = this._trackedStyleKeys.some((key) => styles.custom[key] !== this._styles.custom[key]);\n    this._styles = styles;\n    if (hasTrackedChanges) {\n      this._forceUpdate = true;\n    }\n    if (different) {\n      applyStyle(this.yoga, this._styles.yoga);\n      this.target._onUpdate();\n      this.invalidateRoot();\n    }\n  }\n  /** Marks the root layout as needing recalculation */\n  invalidateRoot() {\n    const root = this.getRoot();\n    root._layout._isDirty = true;\n    root._onUpdate();\n    this._modificationCount++;\n  }\n  /**\n   * Forces an update of the layout even if it hasn\'t changed the yoga node.\n   * This is used to force an update when certain style properties change such as `objectFit`.\n   * Or when you have changed something inside of Pixi that is not tracked by the layout system.\n   */\n  forceUpdate() {\n    this._forceUpdate = true;\n  }\n  /**\n   * Finds the root container by traversing up the layout tree\n   * @returns The root container\n   */\n  getRoot() {\n    var _a, _b;\n    let root = this.target;\n    while (((_a = root.parent) == null ? void 0 : _a._layout) || ((_b = root.parent) == null ? void 0 : _b.isOverflowContainer)) {\n      root = root.parent;\n      if (root.isOverflowContainer) {\n        root = root.parent;\n      }\n    }\n    return root;\n  }\n  /**\n   * @ignore\n   */\n  _onChildAdded(pixiParent) {\n    if (this.hasParent) return;\n    this.hasParent = true;\n    this.invalidateRoot();\n    onChildAdded(this, pixiParent);\n  }\n  /**\n   * @ignore\n   */\n  _onChildRemoved() {\n    if (!this.hasParent) return;\n    this.hasParent = false;\n    this.invalidateRoot();\n    onChildRemoved(this);\n  }\n  destroy() {\n    this.invalidateRoot();\n    this.yoga.free();\n    this.target.off("added", this._onChildAdded, this);\n    this.target.off("removed", this._onChildRemoved, this);\n    this._styles = null;\n    this._computedPixiLayout = null;\n    this._computedLayout = null;\n    this.target = null;\n    this.hasParent = false;\n  }\n}\n/** Default style values to apply to the layout */\n__publicField(Layout, "defaultStyle", {\n  leaf: {\n    width: "intrinsic",\n    height: "intrinsic"\n  },\n  container: {\n    width: "auto",\n    height: "auto"\n  },\n  shared: {\n    transformOrigin: "50%",\n    objectPosition: "center",\n    flexShrink: 1,\n    flexDirection: "row",\n    alignContent: "stretch",\n    flexWrap: "nowrap",\n    overflow: "visible"\n  }\n});\nfunction calculateObjectFit(value, computedLayout, bounds) {\n  let offsetScaleX = 1;\n  let offsetScaleY = 1;\n  switch (value) {\n    case "fill":\n      offsetScaleX = computedLayout.width / bounds.width;\n      offsetScaleY = computedLayout.height / bounds.height;\n      break;\n    case "contain": {\n      const scaleContain = Math.min(computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n      offsetScaleX = scaleContain;\n      offsetScaleY = scaleContain;\n      break;\n    }\n    case "cover": {\n      const scaleCover = Math.max(computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n      offsetScaleX = scaleCover;\n      offsetScaleY = scaleCover;\n      break;\n    }\n    case "none":\n      offsetScaleX = 1;\n      offsetScaleY = 1;\n      break;\n    case "scale-down": {\n      const scaleDown = Math.min(1, computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n      offsetScaleX = scaleDown;\n      offsetScaleY = scaleDown;\n      break;\n    }\n  }\n  return {\n    offsetScaleX,\n    offsetScaleY\n  };\n}\nfunction baseComputeLayoutData(container, computedLayout, defaultObjectFit, anchor) {\n  const bounds = container.getLocalBounds();\n  const objectFit = container.layout.style.objectFit || defaultObjectFit;\n  let { offsetScaleX, offsetScaleY } = calculateObjectFit(objectFit, computedLayout, bounds);\n  const scaledBounds = {\n    width: bounds.width * offsetScaleX,\n    height: bounds.height * offsetScaleY\n  };\n  let { x: offsetX, y: offsetY } = calculatePositionSpecifier(\n    container.layout.style.objectPosition,\n    computedLayout,\n    scaledBounds\n  );\n  if (anchor) {\n    offsetX += bounds.width * offsetScaleX * anchor._x;\n    offsetY += bounds.height * offsetScaleY * anchor._y;\n  } else {\n    offsetX -= bounds.minX * offsetScaleX;\n    offsetY -= bounds.minY * offsetScaleY;\n  }\n  const applySizeDirectly = container.layout.style.applySizeDirectly;\n  if (applySizeDirectly === true || // eslint-disable-next-line eqeqeq\n  applySizeDirectly == void 0 && (container instanceof TilingSprite$1 || container instanceof NineSliceSprite$1)) {\n    container.width = bounds.width * offsetScaleX;\n    container.height = bounds.height * offsetScaleY;\n    offsetScaleX = 1;\n    offsetScaleY = 1;\n  }\n  return {\n    x: computedLayout.left,\n    y: computedLayout.top,\n    offsetX,\n    offsetY,\n    scaleX: offsetScaleX,\n    scaleY: offsetScaleY\n  };\n}\nconst visibility = Object.getOwnPropertyDescriptor(Container.prototype, "visible");\nconst mixin$2 = {\n  // Internal reference to the layout object\n  _layout: null,\n  /**\n   * Gets the current layout associated with this container\n   * @returns The container\'s layout or null if no layout is attached\n   */\n  get layout() {\n    return this._layout ?? null;\n  },\n  /**\n   * Sets the layout for this container\n   * @param value - Layout options to apply, or null to remove layout\n   */\n  set layout(value) {\n    value = value === true ? {} : value;\n    if (!value) {\n      if (this._layout) {\n        this._layout.destroy();\n        this._layout = null;\n        this.updateLocalTransform = Container.prototype.updateLocalTransform;\n        Object.defineProperty(Container.prototype, "visible", visibility);\n      }\n      return;\n    }\n    if (!this._layout) {\n      this._layout = new Layout({ target: this });\n      Object.defineProperty(Container.prototype, "visible", {\n        ...visibility,\n        set(visibleValue) {\n          visibility.set.call(this, visibleValue);\n          if (this.layout) {\n            if (visibleValue && this.parent) {\n              this.layout._onChildAdded(this.parent);\n            } else {\n              this.layout._onChildRemoved();\n            }\n          }\n        }\n      });\n      if (this.parent && this.visible) {\n        this._layout._onChildAdded(this.parent);\n      }\n    }\n    this._layout.setStyle(value);\n    this.updateLocalTransform = this.updateLocalTransformWithLayout;\n    this._onUpdate();\n  },\n  /**\n   * This function overrides how we calculate the local transform of the container.\n   * For the layout, we need to not only calculate the transform matrix, but also\n   * take into account the yoga layout\'s position and scale.\n   */\n  updateLocalTransformWithLayout() {\n    const localTransformChangeId = this._didContainerChangeTick;\n    if (this._didLocalTransformChangeId === localTransformChangeId) return;\n    this._didLocalTransformChangeId = localTransformChangeId;\n    const layout = this._layout;\n    const { x, y, offsetX, offsetY, scaleX, scaleY, originX, originY } = layout._computedPixiLayout;\n    const lt = this.localTransform;\n    const { rotation, skew, scale, position: position2 } = this;\n    const xRotY = rotation + skew._y;\n    const xRotX = rotation - skew._x;\n    const a = Math.cos(xRotY) * scale._x;\n    const b = Math.sin(xRotY) * scale._x;\n    const c = -Math.sin(xRotX) * scale._y;\n    const d = Math.cos(xRotX) * scale._y;\n    const tx = position2._x + x - originX * a - originY * c;\n    const ty = position2._y + y - originX * b - originY * d;\n    lt.a = a * scaleX;\n    lt.b = b * scaleX;\n    lt.c = c * scaleY;\n    lt.d = d * scaleY;\n    lt.tx = tx + (offsetX * a + offsetY * c) + originX;\n    lt.ty = ty + (offsetX * b + offsetY * d) + originY;\n  },\n  /**\n   * Apply the computed layout to the container\n   * Converts Yoga layout information into PixiJS positioning\n   * @param computedLayout - Layout data from Yoga engine\n   * @returns Transformed position and scale data for this container\n   * @memberof scene.Container#\n   */\n  computeLayoutData(computedLayout) {\n    const layout = this._layout;\n    const { isLeaf } = layout._styles.custom;\n    if (isLeaf) {\n      return baseComputeLayoutData(this, computedLayout, "fill");\n    }\n    return {\n      x: computedLayout.left,\n      y: computedLayout.top,\n      offsetX: 0,\n      offsetY: 0,\n      scaleX: 1,\n      scaleY: 1\n    };\n  }\n};\nextensions.mixin(Container, mixin$2);\nconst tempScale = new Point(0, 0);\nconst mixin$1 = {\n  /**\n   * Computes the layout data for the text element\n   * @param computedLayout - The computed layout from Yoga\n   * @returns The layout data for the text element\n   */\n  computeLayoutData(computedLayout) {\n    const style = this._style;\n    tempScale.copyFrom(this.scale);\n    this.scale = 1;\n    if (style.wordWrap) {\n      style.wordWrapWidth = computedLayout.width;\n    }\n    let bounds = this.getLocalBounds();\n    const objectFit = this.layout.style.objectFit || "scale-down";\n    const { offsetScaleX, offsetScaleY } = calculateObjectFit(objectFit, computedLayout, bounds);\n    if (style.wordWrap) {\n      style.wordWrapWidth = computedLayout.width / Math.min(1, Math.max(offsetScaleX, offsetScaleY));\n    }\n    bounds = this.getLocalBounds();\n    const scaledBounds = {\n      width: bounds.width * offsetScaleX,\n      height: bounds.height * offsetScaleY\n    };\n    let { x: offsetX, y: offsetY } = calculatePositionSpecifier(\n      this.layout.style.objectPosition,\n      computedLayout,\n      scaledBounds\n    );\n    offsetX += bounds.width * offsetScaleX * this.anchor._x;\n    offsetY += bounds.height * offsetScaleY * this.anchor._y;\n    const applySizeDirectly = this.layout.style.applySizeDirectly;\n    if (applySizeDirectly === true) {\n      this.width = bounds.width * offsetScaleX;\n      this.height = bounds.height * offsetScaleY;\n    }\n    this.scale.copyFrom(tempScale);\n    return {\n      x: computedLayout.left,\n      y: computedLayout.top,\n      offsetX,\n      offsetY,\n      scaleX: offsetScaleX,\n      scaleY: offsetScaleY\n    };\n  }\n};\nextensions.mixin(AbstractText, mixin$1);\nconst text = Object.getOwnPropertyDescriptor(AbstractText.prototype, "text");\nObject.defineProperty(AbstractText.prototype, "text", {\n  ...text,\n  set(textString) {\n    var _a;\n    const currentText = text.get.call(this);\n    text.set.call(this, textString);\n    if (currentText === textString) return;\n    (_a = this.layout) == null ? void 0 : _a.forceUpdate();\n  }\n});\nconst mixin = {\n  /**\n   * Computes the layout data for the container\n   * @param computedLayout - The computed layout from Yoga\n   * @returns The layout data for the container\n   */\n  computeLayoutData(computedLayout) {\n    return baseComputeLayoutData(this, computedLayout, "fill", this._anchor);\n  }\n};\nextensions.mixin(ViewContainer, mixin);\nvar DebugRegionType = /* @__PURE__ */ ((DebugRegionType2) => {\n  DebugRegionType2["Margin"] = "margin";\n  DebugRegionType2["Padding"] = "padding";\n  DebugRegionType2["Border"] = "border";\n  DebugRegionType2["Flex"] = "flex";\n  DebugRegionType2["Content"] = "content";\n  return DebugRegionType2;\n})(DebugRegionType || {});\nfunction getEdgeValues(layout, type) {\n  const method = `getComputed${type.charAt(0).toUpperCase() + type.slice(1)}`;\n  return {\n    top: layout.yoga[method](Edge.Top),\n    right: layout.yoga[method](Edge.Right),\n    bottom: layout.yoga[method](Edge.Bottom),\n    left: layout.yoga[method](Edge.Left)\n  };\n}\nfunction calculateRegions(layout, regions) {\n  const { width, height } = layout.computedLayout;\n  const margin = getEdgeValues(layout, "margin");\n  const border = getEdgeValues(layout, "border");\n  const padding = getEdgeValues(layout, "padding");\n  const marginRegion = regions.get(\n    "margin"\n    /* Margin */\n  );\n  marginRegion.outer.x = -margin.left;\n  marginRegion.outer.y = -margin.top;\n  marginRegion.outer.width = width + margin.left + margin.right;\n  marginRegion.outer.height = height + margin.top + margin.bottom;\n  marginRegion.inner.x = 0;\n  marginRegion.inner.y = 0;\n  marginRegion.inner.width = width;\n  marginRegion.inner.height = height;\n  const borderRegion = regions.get(\n    "border"\n    /* Border */\n  );\n  borderRegion.outer.x = 0;\n  borderRegion.outer.y = 0;\n  borderRegion.outer.width = width;\n  borderRegion.outer.height = height;\n  borderRegion.inner.x = border.left;\n  borderRegion.inner.y = border.top;\n  borderRegion.inner.width = width - border.left - border.right;\n  borderRegion.inner.height = height - border.top - border.bottom;\n  const paddingRegion = regions.get(\n    "padding"\n    /* Padding */\n  );\n  paddingRegion.outer.copyFrom(borderRegion.inner);\n  paddingRegion.inner.x = padding.left + border.left;\n  paddingRegion.inner.y = padding.top + border.top;\n  paddingRegion.inner.width = width - padding.left - padding.right - border.left - border.right;\n  paddingRegion.inner.height = height - padding.top - padding.bottom - border.top - border.bottom;\n  calculateFlexRegion(layout, regions);\n}\nfunction calculateFlexRegion(layout, regions) {\n  var _a;\n  const flexRegion = regions.get(\n    "flex"\n    /* Flex */\n  );\n  const paddingRegion = regions.get(\n    "padding"\n    /* Padding */\n  );\n  flexRegion.outer.copyFrom(paddingRegion.inner);\n  const bounds = new Bounds();\n  const children = layout.yoga.getChildCount();\n  for (let i = 0; i < children; i++) {\n    const child = layout.yoga.getChild(i);\n    const computedBounds = child.getComputedLayout();\n    bounds.addRect(\n      new Rectangle(computedBounds.left, computedBounds.top, computedBounds.width, computedBounds.height)\n    );\n  }\n  const flexDir = layout.yoga.getFlexDirection();\n  if (flexDir === FlexDirection.Column || flexDir === FlexDirection.ColumnReverse) {\n    bounds.width = flexRegion.outer.width;\n    bounds.x = flexRegion.outer.x;\n  } else {\n    bounds.height = flexRegion.outer.height;\n    bounds.y = flexRegion.outer.y;\n  }\n  (_a = flexRegion.inner) == null ? void 0 : _a.copyFrom(bounds.rectangle);\n  regions.get(\n    "content"\n    /* Content */\n  ).outer.copyFrom(bounds.rectangle);\n}\nfunction lerpColor(start, end, t) {\n  const r = Math.round(start[0] + (end[0] - start[0]) * t);\n  const g = Math.round(start[1] + (end[1] - start[1]) * t);\n  const b = Math.round(start[2] + (end[2] - start[2]) * t);\n  return `rgb(${r},${g},${b})`;\n}\nclass DebugNode extends Container {\n  constructor() {\n    super();\n    /** Graphics objects for each region type */\n    __publicField(this, "graphics");\n    __publicField(this, "heatGraphics");\n    this.graphics = /* @__PURE__ */ new Map();\n    Object.values(DebugRegionType).forEach((type) => {\n      const graphics = new Graphics$1();\n      this.graphics.set(type, graphics);\n      this.addChild(graphics);\n    });\n    this.heatGraphics = new Graphics$1();\n    this.addChild(this.heatGraphics);\n  }\n  /**\n   * Initialize the debug object with region data\n   */\n  init(regions) {\n    const { target, alpha, heat } = regions;\n    if (!regions.heatOnly) {\n      Object.entries(regions).forEach(([type, region]) => {\n        if (type === "target" || type === "alpha" || type === "heat" || type === "heatOnly") return;\n        region = region;\n        const graphics = this.graphics.get(type);\n        if (!graphics || !region.draw) return;\n        if (region.inner) {\n          this.drawCutBox(graphics, region.outer, region.inner, region.color, alpha);\n        } else {\n          const { x, y, width, height } = region.outer;\n          graphics.rect(x, y, width, Math.max(height, 1));\n          graphics.fill({ color: region.color, alpha });\n        }\n      });\n    }\n    const { invalidationCount, draw } = heat;\n    if (invalidationCount > 0 && draw) {\n      const MAX_INVALIDATE_COUNT = 20;\n      const normalizedAlpha = Math.min(invalidationCount / MAX_INVALIDATE_COUNT, 1);\n      const marginRegion = regions[DebugRegionType.Margin];\n      const startColor = [255, 255, 0];\n      const endColor = [255, 0, 0];\n      const color = lerpColor(startColor, endColor, normalizedAlpha);\n      this.heatGraphics.rect(\n        marginRegion.outer.x,\n        marginRegion.outer.y,\n        marginRegion.outer.width,\n        marginRegion.outer.height\n      );\n      this.heatGraphics.fill({ color, alpha: Math.min(0.3, normalizedAlpha) });\n      this.heatGraphics.stroke({ color, alpha: Math.max(0.3, normalizedAlpha), pixelLine: true });\n    }\n    this.position.set(target.x, target.y);\n  }\n  /**\n   * Reset the debug object\'s state\n   */\n  reset() {\n    this.graphics.forEach((graphics) => graphics.clear());\n    this.heatGraphics.clear();\n    this.removeFromParent();\n  }\n  /**\n   * Draw a box with a cut-out center\n   */\n  drawCutBox(graphics, outer, inner, color, alpha) {\n    const { x, y, width, height } = outer;\n    const { x: innerX, y: innerY, width: innerWidth, height: innerHeight } = inner;\n    graphics.rect(x, y, width, height);\n    graphics.fill({ color, alpha });\n    graphics.rect(innerX, innerY, innerWidth, innerHeight);\n    graphics.cut();\n  }\n}\nclass DebugRenderer {\n  constructor() {\n    /** Container for all debug visuals */\n    __publicField(this, "holder", new Container());\n    /** Region data for each debug type */\n    __publicField(this, "regions", /* @__PURE__ */ new Map());\n    /** Color configuration for each region type */\n    __publicField(this, "colors", {\n      [DebugRegionType.Margin]: "#B68655",\n      [DebugRegionType.Padding]: "#BAC57F",\n      [DebugRegionType.Border]: "#E7C583",\n      [DebugRegionType.Content]: "#89B1BE",\n      [DebugRegionType.Flex]: "#6E28D9"\n    });\n    /** Global alpha value for all regions */\n    __publicField(this, "alpha", 0.75);\n    Object.values(DebugRegionType).forEach((type) => {\n      this.regions.set(type, {\n        outer: new Rectangle(),\n        inner: new Rectangle()\n      });\n    });\n    this.holder.__devtoolIgnore = true;\n    this.holder.__devtoolIgnoreChildren = true;\n    this.holder.eventMode = "none";\n    this.holder.interactiveChildren = false;\n  }\n  /**\n   * Clean up previous render state\n   */\n  reset() {\n    for (let i = this.holder.children.length - 1; i >= 0; i--) {\n      const child = this.holder.children[i];\n      BigPool.return(child);\n    }\n  }\n  /**\n   * Render debug visuals for the given layout\n   */\n  render(layout) {\n    calculateRegions(layout, this.regions);\n    const regionData = Object.values(DebugRegionType).reduce(\n      (acc, type) => {\n        const region = this.regions.get(type);\n        if (!region) return acc;\n        const drawString = `debugDraw${type.charAt(0).toUpperCase()}${type.slice(1)}`;\n        acc[type] = {\n          ...region,\n          color: this.colors[type],\n          draw: layout._styles.custom[drawString] ?? true\n        };\n        return acc;\n      },\n      {}\n    );\n    const { left, top } = layout.computedLayout;\n    const pos = layout.target.getGlobalPosition();\n    const debugObject = BigPool.get(DebugNode, {\n      ...regionData,\n      target: { x: pos.x + left, y: pos.y + top },\n      alpha: this.alpha,\n      heat: {\n        invalidationCount: layout._modificationCount,\n        draw: layout._styles.custom.debugHeat !== false\n      },\n      heatOnly: !layout._styles.custom.debug\n    });\n    this.holder.addChildAt(debugObject, 0);\n  }\n  /**\n   * Clean up the debug renderer\n   */\n  destroy() {\n    this.reset();\n    this.holder.destroy();\n    this.regions.clear();\n  }\n}\nconst DebugRenderer$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  DebugRenderer\n}, Symbol.toStringTag, { value: "Module" }));\nextensions.add(LayoutSystem);\nexport {\n  DebugRenderer,\n  Layout,\n  LayoutSystem,\n  applyStyle,\n  formatStyles,\n  getNumberFromStyle,\n  getPixiSize,\n  getTypeFromStyle,\n  getYoga,\n  nearlyEqual,\n  onChildAdded,\n  onChildRemoved,\n  setYoga\n};\n',m='var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);\nimport { Rectangle, Point, Container, Graphics as Graphics$1, Ticker, GraphicsContext, Mesh as Mesh$1, PerspectiveMesh as PerspectiveMesh$1, MeshPlane as MeshPlane$1, MeshRope as MeshRope$1, MeshSimple as MeshSimple$1, Sprite as Sprite$1, NineSliceSprite as NineSliceSprite$1, TilingSprite as TilingSprite$1, AnimatedSprite as AnimatedSprite$1, Texture, Text as Text$1, BitmapText as BitmapText$1, HTMLText as HTMLText$1 } from "pixi.js";\nimport { Edge, BoxSizing } from "yoga-layout/load";\nimport { GifSprite as GifSprite$1, GifSource } from "pixi.js/gif";\nclass Spring {\n  constructor(options = {}) {\n    __publicField(this, "x");\n    __publicField(this, "ax");\n    __publicField(this, "dx");\n    __publicField(this, "tx");\n    __publicField(this, "_options");\n    this.x = 0;\n    this.ax = 0;\n    this.dx = 0;\n    this.tx = 0;\n    this._options = options;\n    this._options.max = options.max ?? 160;\n    this._options.damp = options.damp ?? 0.8;\n    this._options.springiness = options.springiness ?? 0.1;\n  }\n  update() {\n    this.ax = (this.tx - this.x) * this._options.springiness;\n    this.dx += this.ax;\n    this.dx *= this._options.damp;\n    if (this.dx < -this._options.max) this.dx = -this._options.max;\n    else if (this.dx > this._options.max) this.dx = this._options.max;\n    this.x += this.dx;\n  }\n}\nclass ScrollSpring {\n  constructor(springOptions = {}) {\n    __publicField(this, "done");\n    __publicField(this, "to");\n    __publicField(this, "_spring");\n    __publicField(this, "_pos");\n    __publicField(this, "_speed");\n    __publicField(this, "_correctSpeed");\n    this._spring = new Spring(springOptions);\n    this._pos = 0;\n    this.to = 0;\n  }\n  start(speed, pos, to) {\n    this._speed = speed;\n    this._pos = pos;\n    this.to = to;\n    this.done = false;\n    this._spring.x = this._pos;\n    this._spring.tx = this.to;\n    const diff = this.to - this._pos;\n    const toDirection = Math.abs(diff) / diff;\n    const currentDirection = Math.abs(this._speed) / this._speed;\n    if (toDirection !== currentDirection) {\n      this._correctSpeed = true;\n    } else {\n      this._correctSpeed = false;\n    }\n  }\n  update() {\n    if (this._correctSpeed) {\n      this._speed *= 0.6;\n      if (Math.abs(this._speed) < 2) {\n        this._correctSpeed = false;\n      }\n      this._pos += this._speed;\n      this._spring.x = this._pos;\n    } else {\n      const diff = this.to - this._pos;\n      if (Math.abs(diff) < 0.05) {\n        this._pos = this.to;\n        this.done = true;\n      } else {\n        this._spring.tx = this.to;\n        this._spring.update();\n        this._pos = this._spring.x;\n      }\n    }\n    return this._pos;\n  }\n}\nclass SlidingNumber {\n  constructor(options = {}) {\n    __publicField(this, "position", 0);\n    __publicField(this, "constrain", true);\n    __publicField(this, "min", 0);\n    // the window width of the drag\n    __publicField(this, "max", 0);\n    // the window width of the drag\n    __publicField(this, "maxSpeed", 400);\n    __publicField(this, "_ease");\n    __publicField(this, "_offset", 0);\n    __publicField(this, "_prev", 0);\n    __publicField(this, "_speed", 0);\n    __publicField(this, "_hasStopped", true);\n    __publicField(this, "_targetSpeed", 0);\n    __publicField(this, "_speedChecker", 0);\n    __publicField(this, "_grab", 0);\n    __publicField(this, "_activeEase", null);\n    this.constrain = options.constrain ?? true;\n    this.maxSpeed = options.maxSpeed ?? 400;\n    this._ease = options.ease ?? new ScrollSpring();\n  }\n  set value(n) {\n    this._speed = 0;\n    this.position = n;\n  }\n  get value() {\n    return this.position;\n  }\n  grab(offset) {\n    this._grab = offset;\n    this._offset = this.position - offset;\n    this._speedChecker = 0;\n    this._targetSpeed = this._speed = 0;\n    this._hasStopped = false;\n  }\n  hold(newPosition) {\n    this._speedChecker++;\n    this.position = newPosition + this._offset;\n    if (this._speedChecker > 1) {\n      this._targetSpeed = this.position - this._prev;\n    }\n    this._speed += (this._targetSpeed - this._speed) / 2;\n    if (this._speed > this.maxSpeed) this._speed = this.maxSpeed;\n    else if (this._speed < -this.maxSpeed) this._speed = -this.maxSpeed;\n    this._prev = this.position;\n    if (this.constrain) {\n      this._activeEase = null;\n      if (this.position > this.min) {\n        this.position = this.min;\n      } else if (this.position < this.max) {\n        this.position = this.max;\n      }\n    }\n  }\n  slide(instant = false) {\n    if (this._hasStopped) return;\n    if (this.constrain) {\n      this._updateConstrain(instant);\n    } else {\n      this._updateDefault();\n    }\n  }\n  get moveAmount() {\n    return -(this.position - this._offset - this._grab);\n  }\n  _updateDefault() {\n    this._speed *= 0.9;\n    this.position += this._speed;\n    if ((this._speed < 0 ? this._speed * -1 : this._speed) < 0.01) {\n      this._hasStopped = true;\n    }\n    if (this.position > this.min) {\n      this.position = this.min;\n      this._hasStopped = true;\n    } else if (this.position < this.max) {\n      this.position = this.max;\n      this._hasStopped = true;\n    }\n  }\n  _updateConstrain(instant = false) {\n    const max = this.max;\n    if (instant) {\n      if (this.position > this.min) {\n        this.position = this.min;\n      } else if (this.position < this.max) {\n        this.position = this.max;\n      }\n    } else if (this.position > this.min || this.position < max || this._activeEase) {\n      if (!this._activeEase) {\n        this._activeEase = this._ease;\n        if (this.position > this.min) {\n          this._activeEase.start(this._speed, this.position, this.min);\n        } else {\n          this._activeEase.start(this._speed, this.position, max);\n        }\n      }\n      this.position = this._activeEase.update();\n      if (this._activeEase.done) {\n        this.position = this._activeEase.to;\n        this._speed = 0;\n        this._activeEase = null;\n      }\n    } else {\n      this._updateDefault();\n    }\n  }\n}\nclass Trackpad {\n  constructor(options) {\n    __publicField(this, "xAxis");\n    __publicField(this, "yAxis");\n    __publicField(this, "_isDown");\n    __publicField(this, "_globalPosition");\n    __publicField(this, "_frame");\n    __publicField(this, "_bounds");\n    __publicField(this, "_dirty");\n    __publicField(this, "disableEasing", false);\n    this.xAxis = new SlidingNumber({\n      ease: options.xEase,\n      maxSpeed: options.maxSpeed,\n      constrain: options.constrain\n    });\n    this.yAxis = new SlidingNumber({\n      ease: options.yEase,\n      maxSpeed: options.maxSpeed,\n      constrain: options.constrain\n    });\n    this.disableEasing = options.disableEasing ?? false;\n    this._frame = new Rectangle();\n    this._bounds = new Rectangle();\n    this._globalPosition = new Point();\n  }\n  pointerDown(pos) {\n    this._globalPosition = pos;\n    this.xAxis.grab(pos.x);\n    this.yAxis.grab(pos.y);\n    this._isDown = true;\n  }\n  pointerUp() {\n    this._isDown = false;\n  }\n  pointerMove(pos) {\n    this._globalPosition = pos;\n  }\n  update() {\n    if (this._dirty) {\n      this._dirty = false;\n      this.xAxis.min = this._bounds.left;\n      this.xAxis.min = this._bounds.right - this._frame.width;\n      this.xAxis.min = this._bounds.top;\n      this.xAxis.min = this._bounds.bottom - this._frame.height;\n    }\n    if (this._isDown) {\n      this.xAxis.hold(this._globalPosition.x);\n      this.yAxis.hold(this._globalPosition.y);\n    } else {\n      this.xAxis.slide(this.disableEasing);\n      this.yAxis.slide(this.disableEasing);\n    }\n  }\n  resize(w, h) {\n    this._frame.x = 0;\n    this._frame.width = w;\n    this._frame.y = 0;\n    this._frame.height = h;\n    this._dirty = true;\n  }\n  setBounds(minX, maxX, minY, maxY) {\n    this._bounds.x = minX;\n    this._bounds.width = maxX - minX;\n    this._bounds.y = minY;\n    this._bounds.height = maxY - minY;\n    this._dirty = true;\n  }\n  get x() {\n    return this.xAxis.value;\n  }\n  get y() {\n    return this.yAxis.value;\n  }\n}\nclass LayoutContainer extends Container {\n  constructor(params = {}) {\n    const { layout, trackpad, background, ...options } = params;\n    super(options);\n    /** Graphics object used for rendering background and borders */\n    __publicField(this, "background");\n    __publicField(this, "stroke", new Graphics$1({ label: "stroke" }));\n    /** The container that holds the overflow content */\n    __publicField(this, "overflowContainer", new Container({\n      label: "overflowContainer"\n    }));\n    /** The trackpad for handling scrolling */\n    __publicField(this, "_trackpad");\n    /** Mask for overflow handling */\n    __publicField(this, "_mask", new Graphics$1());\n    /** Whether or not the background was created by the user */\n    __publicField(this, "_isUserBackground", false);\n    this.layout = layout ?? {};\n    this.overflowContainer.isOverflowContainer = true;\n    this.background = background ?? new Graphics$1({ label: "background" });\n    this._isUserBackground = !!background;\n    this.addChild(this.background, this.overflowContainer, this._mask, this.stroke);\n    this.addChild = this._addChild;\n    this.removeChild = this._removeChild;\n    this._trackpad = new Trackpad({\n      constrain: true,\n      ...trackpad\n    });\n    this.eventMode = "static";\n    this.on("pointerdown", (e) => this._trackpad.pointerDown(e.global));\n    this.on("pointerup", () => this._trackpad.pointerUp());\n    this.on("pointerupoutside", () => this._trackpad.pointerUp());\n    this.on("pointermove", (e) => this._trackpad.pointerMove(e.global));\n    this.on("pointercancel", () => this._trackpad.pointerUp());\n    this.on("wheel", (e) => {\n      var _a;\n      const overflow = (_a = this.layout) == null ? void 0 : _a.style.overflow;\n      if (overflow !== "scroll") {\n        return;\n      }\n      const shift = e.shiftKey ? 1 : 0;\n      const deltaX = e.deltaX * (shift ? 1 : -1);\n      const deltaY = e.deltaY * (shift ? -1 : 1);\n      const targetX = this._trackpad.xAxis.value - deltaX;\n      const targetY = this._trackpad.yAxis.value - deltaY;\n      this._trackpad.xAxis.value = Math.max(\n        this._trackpad.xAxis.max,\n        Math.min(this._trackpad.xAxis.min, targetX)\n      );\n      this._trackpad.yAxis.value = Math.max(\n        this._trackpad.yAxis.max,\n        Math.min(this._trackpad.yAxis.min, targetY)\n      );\n    });\n    Ticker.shared.add(this.update, this);\n  }\n  _addChild(..._children) {\n    return this.overflowContainer.addChild(..._children);\n  }\n  _removeChild(..._children) {\n    return this.overflowContainer.removeChild(..._children);\n  }\n  /**\n   * Computes the layout data for this container based on yoga calculations and draws the background.\n   * @param computedLayout - The computed layout data from yoga\n   * @returns Position and scale information for the container\n   * @internal\n   */\n  computeLayoutData(computedLayout) {\n    this._drawBackground(computedLayout);\n    return {\n      x: computedLayout.left,\n      y: computedLayout.top,\n      offsetX: 0,\n      offsetY: 0,\n      scaleX: 1,\n      scaleY: 1\n    };\n  }\n  /**\n   * Updates the container mask based on overflow settings\n   * @param width - Container width\n   * @param height - Container height\n   * @param radius - Border radius\n   */\n  _updateMask(width, height, radius = 0) {\n    this._mask.clear();\n    this._mask.roundRect(0, 0, width, height, radius);\n    this._mask.fill(255);\n    this._mask.roundRect(1, 1, width - 2, height - 2, radius);\n    this._mask.cut();\n    this._mask.roundRect(1, 1, width - 2, height - 2, radius);\n    this._mask.fill(65280);\n    this._mask.cut();\n  }\n  _updateBackground(computedLayout) {\n    const layoutStyles = this.layout.style;\n    const { backgroundColor, borderRadius } = layoutStyles;\n    if (this._isUserBackground) {\n      this.background.position.set(0, 0);\n      this.background.setSize(computedLayout.width, computedLayout.height);\n    } else {\n      const background = this.background;\n      background.clear();\n      background.roundRect(0, 0, computedLayout.width, computedLayout.height, borderRadius ?? 0);\n      if (backgroundColor != null) {\n        background.fill({ color: backgroundColor });\n      }\n    }\n  }\n  /**\n   * Draws the container\'s background including:\n   * - Background color\n   * - Border\n   * - Border radius\n   *\n   * @param computedLayout - The computed layout data from yoga\n   * @protected\n   */\n  _drawBackground(computedLayout) {\n    var _a;\n    const borderWidth = this.layout.yoga.getBorder(Edge.All);\n    const boxSizing = this.layout.yoga.getBoxSizing();\n    const alignment = boxSizing === BoxSizing.BorderBox ? 1 : 0;\n    const layoutStyles = this.layout.style;\n    const { borderColor, borderRadius } = layoutStyles;\n    this._updateBackground(computedLayout);\n    this.stroke.clear();\n    if (borderWidth > 0 && borderColor != null) {\n      this.stroke.roundRect(0, 0, computedLayout.width, computedLayout.height, borderRadius ?? 0);\n      this.stroke.stroke({ color: borderColor, width: borderWidth, alignment });\n    }\n    const overflow = (_a = this.layout) == null ? void 0 : _a.style.overflow;\n    if (overflow !== "visible") {\n      this._updateMask(computedLayout.width, computedLayout.height, layoutStyles.borderRadius ?? 0);\n      this.setMask({ mask: this._mask });\n      const borderOffset = boxSizing === BoxSizing.BorderBox ? borderWidth : 0;\n      setTimeout(() => {\n        const maskWidth = computedLayout.width - this.overflowContainer.width - borderOffset * 2;\n        const maskHeight = computedLayout.height - this.overflowContainer.height - borderOffset * 2;\n        this._trackpad.xAxis.max = Math.min(0, maskWidth);\n        this._trackpad.yAxis.max = Math.min(0, maskHeight);\n      }, 1);\n    } else {\n      this.mask = null;\n      this._trackpad.xAxis.value = 0;\n      this._trackpad.yAxis.value = 0;\n      this.overflowContainer.position.set(0, 0);\n    }\n  }\n  update() {\n    var _a;\n    const overflow = (_a = this.layout) == null ? void 0 : _a.style.overflow;\n    if (overflow !== "scroll") {\n      return;\n    }\n    this._trackpad.update();\n    this.overflowContainer.x = this._trackpad.x;\n    this.overflowContainer.y = this._trackpad.y;\n  }\n  destroy(options) {\n    super.destroy(options);\n    Ticker.shared.remove(this.update, this);\n  }\n}\nclass LayoutView extends LayoutContainer {\n  constructor(params) {\n    const { slot, layout, ...rest } = params;\n    super(rest);\n    /** The slot container for holding content */\n    __publicField(this, "slot");\n    this.slot = params.slot ?? new Container({ label: "slot" });\n    this.layout = layout ?? {};\n    this.addChild(this.slot);\n    this.addChild = this._addChild;\n    this.removeChild = this._removeChild;\n  }\n  /**\n   * Gets the current layout associated with this container\n   * @returns The container\'s layout or null if no layout is attached\n   */\n  get layout() {\n    return super.layout;\n  }\n  /**\n   * Sets the layout for this container and configures its slot.\n   *\n   * The layout is split between the container and slot:\n   * - Container: Handles positioning, size, and background\n   * - Slot: Manages content fitting and positioning\n   *\n   * @param value - Layout options to apply, or null to remove layout\n   *\n   * @example\n   * ```typescript\n   * view.layout = {`\n   *     width: \'100%\',\n   *     objectFit: \'contain\',\n   *     objectPosition: \'center\',\n   *     backgroundColor: \'red\'\n   * };\n   * ```\n   */\n  set layout(value) {\n    const { applySizeDirectly, objectFit, objectPosition, isLeaf, ...rest } = value ?? {};\n    super.layout = rest;\n    if (this.layout && this.slot) {\n      this.slot.layout = {\n        width: "100%",\n        height: "100%",\n        objectFit,\n        objectPosition,\n        applySizeDirectly,\n        isLeaf\n      };\n    }\n  }\n  /**\n   * Prevents adding children directly to this container.\n   * Content should be added to the slot instead.\n   *\n   * @throws {Error} Always throws an error to enforce leaf node behavior\n   * @private\n   */\n  _addChild(..._children) {\n    if (this.overflowContainer.children.length > 1) {\n      throw new Error("Leaf nodes should not have multiple children");\n    }\n    return super._addChild(..._children);\n  }\n}\nclass BaseView extends LayoutView {\n  constructor(opts) {\n    const { layout, background, trackpad, ClassType, ...options } = opts;\n    const slot = new ClassType(options);\n    super({\n      slot,\n      layout,\n      background,\n      trackpad\n    });\n  }\n}\nclass LayoutGifSprite extends BaseView {\n  constructor(opts) {\n    if (opts instanceof GifSource) {\n      opts = { source: opts };\n    }\n    super({\n      ...opts,\n      ClassType: GifSprite$1\n    });\n  }\n}\nclass GifSprite extends GifSprite$1 {\n  constructor(opts) {\n    if (opts instanceof GifSource) {\n      opts = { source: opts };\n    }\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutGraphics extends BaseView {\n  constructor(opts) {\n    if (opts instanceof GraphicsContext) {\n      opts = { context: opts };\n    }\n    super({\n      ...opts,\n      ClassType: Graphics$1\n    });\n  }\n}\nclass Graphics extends Graphics$1 {\n  constructor(opts) {\n    if (opts instanceof GraphicsContext) {\n      opts = { context: opts };\n    }\n    const { layout, ...options } = opts ?? {};\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutMesh extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: Mesh$1\n    });\n  }\n}\nclass Mesh extends Mesh$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutPerspectiveMesh extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: PerspectiveMesh$1\n    });\n  }\n}\nclass PerspectiveMesh extends PerspectiveMesh$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutMeshPlane extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: MeshPlane$1\n    });\n  }\n}\nclass MeshPlane extends MeshPlane$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutMeshRope extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: MeshRope$1\n    });\n  }\n}\nclass MeshRope extends MeshRope$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutMeshSimple extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: MeshSimple$1\n    });\n  }\n}\nclass MeshSimple extends MeshSimple$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutSprite extends BaseView {\n  constructor(opts) {\n    if (opts instanceof Texture) {\n      opts = { texture: opts };\n    }\n    super({\n      ...opts,\n      ClassType: Sprite$1\n    });\n  }\n}\nclass Sprite extends Sprite$1 {\n  constructor(opts) {\n    if (opts instanceof Texture) {\n      opts = { texture: opts };\n    }\n    const { layout, ...options } = opts ?? {};\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutNineSliceSprite extends BaseView {\n  constructor(opts) {\n    if (opts instanceof Texture) {\n      opts = { texture: opts };\n    }\n    super({\n      ...opts,\n      ClassType: NineSliceSprite$1\n    });\n  }\n}\nclass NineSliceSprite extends NineSliceSprite$1 {\n  constructor(opts) {\n    if (opts instanceof Texture) {\n      opts = { texture: opts };\n    }\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutTilingSprite extends BaseView {\n  constructor(opts) {\n    if (opts instanceof Texture) {\n      opts = { texture: opts };\n    }\n    super({\n      ...opts,\n      ClassType: TilingSprite$1\n    });\n  }\n}\nclass TilingSprite extends TilingSprite$1 {\n  constructor(opts) {\n    if (opts instanceof Texture) {\n      opts = { texture: opts };\n    }\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutAnimatedSprite extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: AnimatedSprite$1\n    });\n  }\n}\nclass AnimatedSprite extends AnimatedSprite$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutText extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: Text$1\n    });\n  }\n}\nclass Text extends Text$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutBitmapText extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: BitmapText$1\n    });\n  }\n}\nclass BitmapText extends BitmapText$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts;\n    super(options);\n    this.layout = layout;\n  }\n}\nclass LayoutHTMLText extends BaseView {\n  constructor(opts) {\n    super({\n      ...opts,\n      ClassType: HTMLText$1\n    });\n  }\n}\nclass HTMLText extends HTMLText$1 {\n  constructor(opts) {\n    const { layout, ...options } = opts ?? {};\n    super(options);\n    this.layout = layout;\n  }\n}\nexport {\n  AnimatedSprite,\n  BitmapText,\n  GifSprite,\n  Graphics,\n  HTMLText,\n  LayoutAnimatedSprite,\n  LayoutBitmapText,\n  LayoutContainer,\n  LayoutGifSprite,\n  LayoutGraphics,\n  LayoutHTMLText,\n  LayoutMesh,\n  LayoutMeshPlane,\n  LayoutMeshRope,\n  LayoutMeshSimple,\n  LayoutNineSliceSprite,\n  LayoutPerspectiveMesh,\n  LayoutSprite,\n  LayoutText,\n  LayoutTilingSprite,\n  LayoutView,\n  Mesh,\n  MeshPlane,\n  MeshRope,\n  MeshSimple,\n  NineSliceSprite,\n  PerspectiveMesh,\n  Sprite,\n  Text,\n  TilingSprite\n};\n',_="import './App';\nimport './styles.css';\n",x="import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from './App';\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n",b="body {\n    margin: 0;\n    overflow: hidden;\n}\n";var v=n(9995),w=n(2323);function S(e){let{viewType:t="both",showConsole:n=!1,width:s="100%",height:a="100%",dependencies:r={"pixi.js":"latest"},files:d={},fontSize:h=12,handleEditorCodeChanged:p,type:y="react"}=e;const{colorMode:S}=(0,u.G)(),C={...d};r="javascript"===y?{"pixi.js":"latest","yoga-layout":"latest",...r}:{"@pixi/react":"latest","pixi.js":"latest",react:"^19","react-dom":"^19","yoga-layout":"latest",...r};const[L]=(0,o.useState)({"/styles.css":{code:b,hidden:!0},"sandbox.config.json":{code:'{"infiniteLoopProtection": false}',hidden:!0},"/public/index.html":{code:'<!DOCTYPE html>\n            <html lang="en">\n            <head>\n                <meta charset="UTF-8">\n                <meta name="viewport" content="width=device-width, initial-scale=1.0">\n                <title>Document</title>\n            </head>\n            <body>\n                <div id="root"></div>\n            </body>\n            </html>',hidden:!0},"/index.js":{code:"javascript"===y?_:x,hidden:!0},"/layout/index.js":{hidden:!0,code:f},"/layout/components.js":{hidden:!0,code:m},...C});return(0,c.jsx)(w.A,{children:()=>(0,c.jsx)(l.l5,{template:"react",theme:"dark"===S?i:v.al,files:L,customSetup:{dependencies:r,devDependencies:{"babel-plugin-module-resolver":"latest"}},style:{height:a,width:s,margin:"0 auto",maxWidth:"100%"},options:{recompileDelay:500},children:(0,c.jsx)(g,{fontSize:h,handleEditorCodeChanged:p,pixiVersion:r["pixi.js"],showConsole:n,viewType:t})})})}},6614:(e,t,n)=>{n.d(t,{m:()=>a});var o=n(117),i=n(1573),s=n(2540);function a(e){return(0,i.z)("example",!0),(0,s.jsx)(o.K,{height:"calc(100vh - 325px)",fontSize:14,...e})}},1573:(e,t,n)=>{n.d(t,{z:()=>i});var o=n(3696);const i=function(e,t){void 0===t&&(t=!0),(0,o.useEffect)((()=>{const n=document.querySelector("main > .container");if(null!==n&&t)return n.classList.add(e),()=>{n.classList.remove(e)}}),[e,t])}},5430:(e,t,n)=>{n.d(t,{A:()=>o});const o="import { Application, extend, useApplication } from '@pixi/react';\nimport { Assets } from 'pixi.js';\n\nimport { useEffect, useState } from 'react';\n// NOTE: this should be replaced with `@pixi/layout/components`\nimport {\n    Container,\n    GifSprite,\n    Graphics,\n    Mesh,\n    PerspectiveMesh,\n    MeshPlane,\n    MeshRope,\n    MeshSimple,\n    Sprite,\n    NineSliceSprite,\n    TilingSprite,\n    AnimatedSprite,\n    LayoutContainer,\n    LayoutGifSprite,\n    LayoutGraphics,\n    LayoutMesh,\n    LayoutPerspectiveMesh,\n    LayoutMeshPlane,\n    LayoutMeshRope,\n    LayoutMeshSimple,\n    LayoutSprite,\n    LayoutNineSliceSprite,\n    LayoutTilingSprite,\n    LayoutAnimatedSprite,\n} from '/layout/components';\n\n// extend tells @pixi/react what PixiJS components are available\nextend({\n    Container,\n    GifSprite,\n    Graphics,\n    Mesh,\n    PerspectiveMesh,\n    MeshPlane,\n    MeshRope,\n    MeshSimple,\n    Sprite,\n    NineSliceSprite,\n    TilingSprite,\n    AnimatedSprite,\n    LayoutContainer,\n    LayoutGifSprite,\n    LayoutGraphics,\n    LayoutMesh,\n    LayoutPerspectiveMesh,\n    LayoutMeshPlane,\n    LayoutMeshRope,\n    LayoutMeshSimple,\n    LayoutSprite,\n    LayoutNineSliceSprite,\n    LayoutTilingSprite,\n    LayoutAnimatedSprite,\n});\n\nconst LayoutResizer = ({ children }) => {\n    const { app } = useApplication();\n\n    app.stage.layout = {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        justifyContent: 'center',\n        alignItems: 'center',\n    };\n\n    // listen for resize events on the renderer\n    app.renderer.on('resize', () => {\n        app.stage.layout = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n    });\n\n    return children;\n};\n\nexport default function App({ children, assets }) {\n    const [isInitialized, setIsInitialized] = useState(false);\n\n    useEffect(() => {\n        const start = async () => {\n            assets ??= [];\n            const parsedAssets = assets.map((asset) => {\n                if (asset.startsWith('https://fakeimg.pl/')) {\n                    return {\n                        alias: asset,\n                        src: asset,\n                        loadParser: 'loadTextures',\n                    };\n                }\n\n                return asset;\n            });\n\n            // Perform async initialization here\n            await Assets.load(parsedAssets);\n            setIsInitialized(true);\n        };\n\n        void start();\n    }, []);\n\n    if (!isInitialized) {\n        return <div>Loading...</div>;\n    }\n\n    return (\n        <Application resizeTo={window} background={'#1C1C1D'}>\n            <LayoutResizer>{children}</LayoutResizer>\n        </Application>\n    );\n}\n"}}]);