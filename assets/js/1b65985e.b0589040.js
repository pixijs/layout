"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1504],{3023:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(3696);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},7053:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/core/overview","title":"Overview","description":"Overview","source":"@site/docs/guides/core/overview.md","sourceDirName":"guides/core","slug":"/guides/core/overview","permalink":"/docs/guides/core/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/layout/tree/main/website/docs/docs/guides/core/overview.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"title":"Overview","hide_title":true,"sidebar_position":0},"sidebar":"guides","previous":{"title":"Opt-in Layout","permalink":"/docs/guides/core/concepts/opt-in-layout"},"next":{"title":"Layout API","permalink":"/docs/guides/core/layout"}}');var s=i(2540),o=i(3023);const r={title:"Overview",hide_title:!0,sidebar_position:0},a=void 0,l={},d=[{value:"Overview",id:"overview",level:2},{value:"\ud83d\udcd8 Concepts",id:"-concepts",level:2},{value:"\ud83d\udcd0 Yoga + Flexbox Model",id:"-yoga--flexbox-model",level:3},{value:"\ud83e\uddf1 Everything is a Box",id:"-everything-is-a-box",level:3},{value:"\ud83d\udd27 Opt-in Layout and Mixed Modes",id:"-opt-in-layout-and-mixed-modes",level:3},{value:"\ud83e\udde9 Layout Components &amp; Re-exports",id:"-layout-components--re-exports",level:3},{value:"\ud83d\udd01 Intrinsic Sizing",id:"-intrinsic-sizing",level:3},{value:"\ud83e\udded Transform Origin and Layout Transforms",id:"-transform-origin-and-layout-transforms",level:3},{value:"Position and Scale Normalization",id:"position-and-scale-normalization",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["PixiJS Layout brings a powerful, declarative, and responsive layout model to the 2D rendering power of PixiJS. Built on top of Facebook's ",(0,s.jsx)(n.a,{href:"https://www.yogalayout.dev/",children:"Yoga"})," Flexbox layout engine, it allows developers to create dynamic UIs, responsive game interfaces, and fluid application components \u2014 all inside PixiJS."]}),"\n",(0,s.jsxs)(n.p,{children:["This guide covers the foundational principles behind the ",(0,s.jsx)(n.code,{children:"@pixi/layout"})," system. It explains how layout is applied, how nodes are measured and styled, and how the system integrates flexibly into PixiJS projects."]}),"\n",(0,s.jsx)(n.h2,{id:"-concepts",children:"\ud83d\udcd8 Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"-yoga--flexbox-model",children:"\ud83d\udcd0 Yoga + Flexbox Model"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@pixi/layout"})," is powered by ",(0,s.jsx)(n.a,{href:"https://www.yogalayout.dev/",children:"Yoga"}),", a cross-platform layout engine that implements a subset of the CSS Flexbox specification. If you're familiar with how Flexbox works in HTML/CSS, you'll find many parallels in how layout rules work here."]}),"\n",(0,s.jsxs)(n.p,{children:["Key properties such as ",(0,s.jsx)(n.code,{children:"flexDirection"}),", ",(0,s.jsx)(n.code,{children:"justifyContent"}),", ",(0,s.jsx)(n.code,{children:"alignItems"}),", ",(0,s.jsx)(n.code,{children:"gap"}),", and ",(0,s.jsx)(n.code,{children:"flexWrap"})," work as expected and follow the same logic as in web development."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"-everything-is-a-box",children:"\ud83e\uddf1 Everything is a Box"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"@pixi/layout"}),", ",(0,s.jsx)(n.strong,{children:"everything is conceptually a box"}),". This reflects the CSS box model:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Containers represent layout groups, analogous to HTML ",(0,s.jsx)(n.code,{children:"<div>"})," elements. They do not render visual content directly, but define layout regions that arrange and position children."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Leaf nodes such as ",(0,s.jsx)(n.code,{children:"Sprite"}),", ",(0,s.jsx)(n.code,{children:"Graphics"}),", ",(0,s.jsx)(n.code,{children:"Text"}),", ",(0,s.jsx)(n.code,{children:"BitmapText"}),", and ",(0,s.jsx)(n.code,{children:"TilingSprite"})," are analogous to HTML ",(0,s.jsx)(n.code,{children:"<img>"})," elements. These nodes are visual and content-bearing."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Each node in the tree has a virtual layout box, and the position and size of that box is calculated by the layout engine. Visual elements can additionally scale or crop their internal content using style properties like ",(0,s.jsx)(n.code,{children:"objectFit"})," and ",(0,s.jsx)(n.code,{children:"objectPosition"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const container = new Container({\n    layout: {\n        width: 500,\n        height: 300,\n        flexWrap: 'wrap',\n        justifyContent: 'center',\n        alignContent: 'center',\n    },\n});\n\nconst sprite = new Sprite({ texture });\nsprite.layout = {\n    width: 100,\n    height: 100,\n    objectFit: 'contain',\n    objectPosition: 'center',\n};\n\ncontainer.addChild(sprite);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"-opt-in-layout-and-mixed-modes",children:"\ud83d\udd27 Opt-in Layout and Mixed Modes"}),"\n",(0,s.jsxs)(n.p,{children:["One of the defining strengths of ",(0,s.jsx)(n.code,{children:"@pixi/layout"})," is its ",(0,s.jsx)(n.strong,{children:"non-invasive"}),", ",(0,s.jsx)(n.strong,{children:"opt-in"})," design. Layout logic is only applied when explicitly requested. This enables seamless integration into existing PixiJS projects and flexibility:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A parent will only apply layout to children that ",(0,s.jsx)(n.strong,{children:"have layout enabled"})," (",(0,s.jsx)(n.code,{children:"layout"})," property)."]}),"\n",(0,s.jsxs)(n.li,{children:["Children without layout are ",(0,s.jsx)(n.strong,{children:"unaffected"})," and behave just like standard PixiJS objects."]}),"\n",(0,s.jsx)(n.li,{children:"This makes the system safe by default and easy to adopt incrementally."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const container = new Container({\n    layout: {\n        width: 500,\n        height: 500,\n        justifyContent: 'center',\n    },\n});\n\nconst managed = new Sprite({ texture, layout: true });\nconst unmanaged = new Sprite(texture); // not in layout\n\ncontainer.addChild(managed, unmanaged);\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this case:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"managed"})," will be centered in the layout box (positioned at 250,250)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"unmanaged"})," will be placed at 0,0, unless you set its .x and .y manually."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"-layout-components--re-exports",children:"\ud83e\udde9 Layout Components & Re-exports"}),"\n",(0,s.jsx)(n.p,{children:"Some styles are only supported on specialized container components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"backgroundColor"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"borderRadius"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"overflow"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["These styles are ",(0,s.jsx)(n.strong,{children:"not available"})," on standard PixiJS containers / leaf nodes. If you need them, use:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutContainer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutSprite"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutTilingSprite"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutNineSlicePlane"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutAnimatedSprite"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutGifSprite"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutGraphics"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutText"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutBitmapText"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutHTMLText"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutMesh"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutPerspectiveMesh"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutMeshPlane"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutMeshRope"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LayoutMeshSimple"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These custom components simply wrap a leaf node inside of a standard PixiJS Container and adds additional graphics to draw backgrounds and borders."}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, all PixiJS leaf nodes are ",(0,s.jsx)(n.strong,{children:"re-exported"})," in ",(0,s.jsx)(n.code,{children:"@pixi/layout"})," with the ",(0,s.jsx)(n.code,{children:"layout"})," property applied ",(0,s.jsx)(n.strong,{children:"after"})," initialization. This is essential for correct intrinsic sizing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { LayoutContainer } from '@pixi/layout/components';\nimport { Sprite, Graphics, Text } from '@pixi/layout/components';\n\nconst container = new LayoutContainer({\n    layout: {\n        width: 500,\n        height: 300,\n        flexWrap: 'wrap',\n        justifyContent: 'center',\n        alignContent: 'center',\n        backgroundColor: 0x000000,\n        borderRadius: 10,\n    },\n});\n\nconst sprite = new Sprite({ texture, layout: true });\nconst graphics = new Graphics({ layout: true });\nconst text = new Text({ text: 'Hello World', layout: true });\n\ncontainer.addChild(sprite, graphics, text);\n"})}),"\n",(0,s.jsx)(n.p,{children:"It is not necessary to use the re-exports, but it is recommended as this is the safest way to ensure that the layout property is assigned last in the constructor."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"-intrinsic-sizing",children:"\ud83d\udd01 Intrinsic Sizing"}),"\n",(0,s.jsxs)(n.p,{children:["By default, all leaf nodes use the ",(0,s.jsx)(n.code,{children:"'intrinsic'"})," property for ",(0,s.jsx)(n.code,{children:"width/height"})," to size a node based on its current PixiJS Bounds"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"sprite.layout = true;\n// This is equivalent to:\nsprite.layout = {\n    width: 'intrinsic',\n    height: 'intrinsic',\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Intrinsic sizing does have a performance impact as we have to check the bounds of the node periodically. This is not a problem for most use cases, but if you are using a lot of nodes, you may want to consider using fixed sizes instead."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"sprite.layout = {\n    width: sprite.width,\n    height: sprite.height,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can combine intrinsic sizing with other layout styles:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"text.layout = {\n    width: 200,\n    height: 'intrinsic',\n    objectFit: 'scale-down',\n};\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"-transform-origin-and-layout-transforms",children:"\ud83e\udded Transform Origin and Layout Transforms"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"transformOrigin"})," property defines the ",(0,s.jsx)(n.strong,{children:"pivot point for rotation/scaling"}),", but applies to the ",(0,s.jsx)(n.strong,{children:"layout box"}),", not the PixiJS element."]}),"\n",(0,s.jsx)(n.p,{children:"This is conceptually similar to transform-origin in CSS. Instead of modifying a sprite\u2019s anchor or pivot, you should use transformOrigin to ensure the layout and visual transforms remain synchronized."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"sprite.layout = {\n    width: 300,\n    height: 300,\n    objectFit: 'cover',\n    transformOrigin: 'center',\n};\n\nsprite.rotation = 0.2; // rotates around center of the layout box\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"anchor"})," and ",(0,s.jsx)(n.code,{children:"pivot"})," will be ignored when a PixiJS object has layout enabled."]}),"\n",(0,s.jsx)(n.h3,{id:"position-and-scale-normalization",children:"Position and Scale Normalization"}),"\n",(0,s.jsx)(n.p,{children:"Regardless of how the content is fit inside the layout box (e.g. using objectFit: 'cover'), the layout box\u2019s transform is always normalized:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"position.x"})," and ",(0,s.jsx)(n.code,{children:"position.y"})," are always ",(0,s.jsx)(n.code,{children:"0"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"scale.x"})," and ",(0,s.jsx)(n.code,{children:"scale.y"})," are always ",(0,s.jsx)(n.code,{children:"1"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The actual transform is handled by internal layout calculations, so that display objects remain animatable and decoupled from layout logic."}),"\n",(0,s.jsx)(n.p,{children:"This normalization simplifies transforms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You can apply rotation, alpha, or even scale animations without worrying about internal layout state."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"All content layout happens inside the box, and the visual content is internally scaled and positioned via computed layout data."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const sprite = new Sprite({ texture });\nsprite.layout = {\n    width: 300,\n    height: 300,\n    objectFit: 'cover',\n    transformOrigin: 'center',\n};\n\nsprite.scale = 2; // scales as if the box was 600x600\nsprite.rotation = 0.2; // rotates around center of the layout box\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);