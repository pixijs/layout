"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4083],{537:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"guides/core/concepts/transform-origin","title":"Layout Transforms","description":"Layout Transforms","source":"@site/docs/guides/core/concepts/transform-origin.md","sourceDirName":"guides/core/concepts","slug":"/guides/core/concepts/transform-origin","permalink":"/docs/guides/core/concepts/transform-origin","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/layout/tree/main/website/docs/docs/guides/core/concepts/transform-origin.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Layout Transforms","hide_title":true,"sidebar_position":2},"sidebar":"guides","previous":{"title":"Containers and Leaf Nodes","permalink":"/docs/guides/core/concepts/containers-leaf-nodes"},"next":{"title":"Opt-in Layout","permalink":"/docs/guides/core/concepts/opt-in-layout"}}');var i=n(2540),s=n(3023);const r={title:"Layout Transforms",hide_title:!0,sidebar_position:2},a=void 0,d={},c=[{value:"Layout Transforms",id:"layout-transforms",level:2},{value:"Transform Origin",id:"transform-origin",level:2},{value:"Position and Scale Normalization",id:"position-and-scale-normalization",level:2},{value:"Applying Size",id:"applying-size",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"layout-transforms",children:"Layout Transforms"}),"\n",(0,i.jsx)(t.p,{children:"PixiJS Layout introduces a new way to handle transforms that differs from the traditional PixiJS approach. This allows for a more familiar and consistent experience for web developers, especially those accustomed to CSS."}),"\n",(0,i.jsx)(t.h2,{id:"transform-origin",children:"Transform Origin"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"transformOrigin"})," property defines the ",(0,i.jsx)(t.strong,{children:"pivot point for rotation/scaling"}),", but applies to the ",(0,i.jsx)(t.strong,{children:"layout box"}),", not the PixiJS element. This property works for both containers and leaf nodes."]}),"\n",(0,i.jsxs)(t.p,{children:["This is conceptually similar to transform-origin in CSS. Instead of modifying a sprite\u2019s ",(0,i.jsx)(t.code,{children:"anchor"})," or ",(0,i.jsx)(t.code,{children:"pivot"}),", you should use ",(0,i.jsx)(t.code,{children:"transformOrigin"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"sprite.layout = {\n    width: 300,\n    height: 300,\n    transformOrigin: 'center',\n};\n\nsprite.rotation = 0.2; // rotates around center of the layout box\n"})}),"\n",(0,i.jsxs)(t.p,{children:["To avoid confusion, the ",(0,i.jsx)(t.code,{children:"anchor"})," and ",(0,i.jsx)(t.code,{children:"pivot"})," properties are not used in the context of layout. If a node has either of these properties set, they are ignored when calculating the layout box."]}),"\n",(0,i.jsx)(t.h2,{id:"position-and-scale-normalization",children:"Position and Scale Normalization"}),"\n",(0,i.jsxs)(t.p,{children:["In PixiJS Layout, the ",(0,i.jsx)(t.code,{children:"position"})," and ",(0,i.jsx)(t.code,{children:"scale"})," properties of a node are always normalized to the layout box, not the position of the node within the parent container or the scale applied to the nodes content."]}),"\n",(0,i.jsx)(t.p,{children:"This means that when a node has layout enabled the following is true:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"sprite.position.x"})," and ",(0,i.jsx)(t.code,{children:"sprite.position.y"})," is always ",(0,i.jsx)(t.code,{children:"0"})," by default even if the node is the third item in a flexbox."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"sprite.scale.x"})," and ",(0,i.jsx)(t.code,{children:"sprite.scale.y"})," is always ",(0,i.jsx)(t.code,{children:"1"})," by default, regardless of properties like ",(0,i.jsx)(t.code,{children:"objectFit"})," which may scale the content inside of the layout box."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The reason for this approach is that normalization simplifies transforms meaning you can animate the layout with ease."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const sprite = new Sprite({ texture });\nsprite.layout = {\n    width: 300,\n    height: 300,\n    objectFit: 'cover',\n    transformOrigin: 'center',\n};\n\nsprite.scale = 2; // scales as if the box was 600x600\nsprite.rotation = 0.2; // rotates around center of the layout box\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It is possible to get the real position and scale of the node and the documentation for that is in the ",(0,i.jsx)(t.a,{href:"/docs/guides/core/layout#real-positionscale",children:"Layout API"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"applying-size",children:"Applying Size"}),"\n",(0,i.jsxs)(t.p,{children:["In PixiJs Layout, when a node has layout enabled, we do not call ",(0,i.jsx)(t.code,{children:"sprite.width"})," or ",(0,i.jsx)(t.code,{children:"sprite.height"})," to set the size of the node. Instead, we apply any size changes directly to the local transform matrix of the node."]}),"\n",(0,i.jsxs)(t.p,{children:["However, sometimes you may want to apply the size directly to the node as the setter for ",(0,i.jsx)(t.code,{children:"width"})," and ",(0,i.jsx)(t.code,{children:"height"})," might have been overridden.\nThis is done by setting the ",(0,i.jsx)(t.code,{children:"applySizeDirectly"})," property to ",(0,i.jsx)(t.code,{children:"true"})," on the layout object."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, many PixiJS UI components override the ",(0,i.jsx)(t.code,{children:"width"})," and ",(0,i.jsx)(t.code,{children:"height"})," setters to modify the size of the node. This means that you should set ",(0,i.jsx)(t.code,{children:"applySizeDirectly"})," to ",(0,i.jsx)(t.code,{children:"true"})," to ensure that component works as expected."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { ProgressBar } from '@pixi/ui';\n\nconst progressBar = new ProgressBar({...});\nprogressBar.layout = {\n    width: 300,\n    height: 300,\n    applySizeDirectly: true,\n};\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"warning",children:[(0,i.jsx)(t.mdxAdmonitionTitle,{children:(0,i.jsx)(t.strong,{children:"Important"})}),(0,i.jsxs)(t.p,{children:["If you set ",(0,i.jsx)(t.code,{children:"applySizeDirectly"})," to ",(0,i.jsx)(t.code,{children:"true"})," and the width/height setters adjust the scale of the node as well, you may end up with unexpected results."]})]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},3023:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(3696);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);